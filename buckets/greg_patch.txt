Index: include/httpd.h
===================================================================
RCS file: /home/cvs/apache-2.0/src/include/httpd.h,v
retrieving revision 1.64
diff -u -r1.64 httpd.h
--- include/httpd.h	2000/06/30 21:18:13	1.64
+++ include/httpd.h	2000/07/12 11:00:55
@@ -731,7 +731,9 @@
 #ifdef APACHE_XLATE
     struct ap_rr_xlate *rrx;
 #endif /*APACHE_XLATE*/
-    
+
+    struct ap_filter_t *filters;
+
 /* Things placed at the end of the record to avoid breaking binary
  * compatibility.  It would be nice to remember to reorder the entire
  * record to improve 64bit alignment the next time we need to break
Index: main/http_protocol.c
===================================================================
RCS file: /home/cvs/apache-2.0/src/main/http_protocol.c,v
retrieving revision 1.95
diff -u -r1.95 http_protocol.c
--- main/http_protocol.c	2000/07/11 03:48:18	1.95
+++ main/http_protocol.c	2000/07/12 11:01:10
@@ -77,6 +77,8 @@
 #include "util_date.h"          /* For parseHTTPdate and BAD_DATE */
 #include "util_charset.h"
 #include "mpm_status.h"
+#include "ap_filter.h"
+
 #ifdef HAVE_STDARG_H
 #include <stdarg.h>
 #endif
@@ -99,6 +101,9 @@
           ap_bgetopt (r->connection->client, BO_BYTECT, &r->bytes_sent); \
   } while (0)
 
+#define DECL_FILTER_HEAD(r, f) \
+    ap_filter_t f = { NULL, (r), NULL, 0, (r)->filters }
+
 
 /* if this is the first error, then log an INFO message and shut down the
  * connection.
@@ -406,6 +411,9 @@
 
 API_EXPORT(int) ap_set_content_length(request_rec *r, long clength)
 {
+    if (r->filters != NULL)
+        return 0;
+
     r->clength = clength;
     ap_table_setn(r->headers_out, "Content-Length", ap_psprintf(r->pool, "%ld", clength));
     return 0;
@@ -1277,8 +1285,17 @@
     rnew->main = (request_rec *) r;
 }
 
+static void flush_filters(request_rec *r)
+{
+    DECL_FILTER_HEAD(r, filter);
+    ap_bucket_t bucket = { AP_BUCKET_EOS };
+
+    ap_fc_putbucket(&filter, &bucket);
+}
+
 void ap_finalize_sub_req_protocol(request_rec *sub)
 {
+    flush_filters(sub);
     SET_BYTES_SENT(sub->main);
 }
 
@@ -1832,11 +1849,6 @@
 #endif /*APACHE_XLATE*/
 }
 
-static void flush_filters(request_rec *r)
-{
-    /* ### place holder to flush pending content through the filters */
-}
-
 /* finalize_request_protocol is called at completion of sending the
  * response.  It's sole purpose is to send the terminating protocol
  * information for any wrappers around the response message body
@@ -2475,107 +2487,88 @@
 
 API_EXPORT(int) ap_rputc(int c, request_rec *r)
 {
+    DECL_FILTER_HEAD(r, filter);
+
     if (r->connection->aborted)
         return EOF;
 
-    if (ap_bputc(c, r->connection->client) < 0) {
-        check_first_conn_error(r, "rputc", 0);
-        return EOF;
-    }
+    ap_fc_putc(&filter, c);
+
     SET_BYTES_SENT(r);
-    return c;
+    return 1;
 }
 
 API_EXPORT(int) ap_rputs(const char *str, request_rec *r)
 {
-    int rcode;
+    DECL_FILTER_HEAD(r, filter);
 
     if (r->connection->aborted)
         return EOF;
     
-    rcode = ap_bputs(str, r->connection->client);
-    if (rcode < 0) {
-        check_first_conn_error(r, "rputs", 0);
-        return EOF;
-    }
+    ap_fc_puts(&filter, str);
+
     SET_BYTES_SENT(r);
-    return rcode;
+    return 1;
 }
 
 API_EXPORT(int) ap_rwrite(const void *buf, int nbyte, request_rec *r)
 {
-    ap_ssize_t n;
-    ap_status_t rv;
+    DECL_FILTER_HEAD(r, filter);
 
     if (r->connection->aborted)
         return EOF;
 
-    /* ### should loop to avoid partial writes */
-    rv = ap_bwrite(r->connection->client, buf, nbyte, &n);
-    if (rv != APR_SUCCESS) {
-        check_first_conn_error(r, "rwrite", rv);
-        return EOF;
-    }
+    ap_fc_write(&filter, buf, nbyte);
+
     SET_BYTES_SENT(r);
-    return n;
+    return nbyte;
 }
 
 API_EXPORT(int) ap_vrprintf(request_rec *r, const char *fmt, va_list va)
 {
-    int n;
+    DECL_FILTER_HEAD(r, filter);
 
     if (r->connection->aborted)
         return EOF;
 
-    n = ap_vbprintf(r->connection->client, fmt, va);
+    ap_fc_vprintf(&filter, fmt, va);
 
-    if (n < 0) {
-        check_first_conn_error(r, "vrprintf", 0);
-        return EOF;
-    }
     SET_BYTES_SENT(r);
-    return n;
+    return 1;
 }
 
 API_EXPORT_NONSTD(int) ap_rprintf(request_rec *r, const char *fmt, ...)
 {
     va_list va;
-    int n;
+
+    DECL_FILTER_HEAD(r, filter);
 
     if (r->connection->aborted)
         return EOF;
 
     va_start(va, fmt);
-    n = ap_vbprintf(r->connection->client, fmt, va);
+    ap_fc_vprintf(&filter, fmt, va);
     va_end(va);
 
-    if (n < 0) {
-        check_first_conn_error(r, "rprintf", 0);
-        return EOF;
-    }
     SET_BYTES_SENT(r);
-    return n;
+    return 1;
 }
 
 API_EXPORT_NONSTD(int) ap_rvputs(request_rec *r, ...)
 {
     va_list va;
-    int n;
+
+    DECL_FILTER_HEAD(r, filter);
 
     if (r->connection->aborted)
         return EOF;
 
     va_start(va, r);
-    n = ap_vbputstrs(r->connection->client, va);
+    ap_fc_vputstrs(&filter, va);
     va_end(va);
 
-    if (n < 0) {
-        check_first_conn_error(r, "rvputs", 0);
-        return EOF;
-    }
-
     SET_BYTES_SENT(r);
-    return n;
+    return 1;
 }
 
 API_EXPORT(int) ap_rflush(request_rec *r)
@@ -2589,6 +2582,210 @@
     return 0;
 }
 
+static void BUFF_filter_callback(ap_filter_t *filter, ap_bucket_t *bucket)
+{
+    ap_bucket_t *bscan = bucket;
+
+    for (bscan = bucket; bscan != NULL; bscan = bscan->next) {
+        int n = 0;
+
+        switch (bscan->type) {
+        case AP_BUCKET_PTRLEN:
+            if (bscan->len == 1) {
+                n = ap_bputc(*bscan->buf, filter->r->connection->client);
+            }
+            else {
+                ap_status_t rv;
+                ap_ssize_t written;
+
+                /* ### should loop to ensure everything is written */
+                rv = ap_bwrite(filter->r->connection->client, bscan->buf,
+                               bscan->len, &written);
+                if (rv != APR_SUCCESS) {
+                    check_first_conn_error(filter->r, "BUFF_filter_callback",
+                                           rv);
+                }
+                /* fallthru; n == 0 */
+            }
+            break;
+
+        case AP_BUCKET_STRINGS:
+            n = ap_vbputstrs(filter->r->connection->client, bscan->va);
+            break;
+
+        case AP_BUCKET_PRINTF:
+            n = ap_vbprintf(filter->r->connection->client, bscan->fmt,
+                            bscan->va);
+            break;
+
+        case AP_BUCKET_FILE:
+            /* ### fill in file case */
+            /* ### fallthru; n == 0 */
+            break;
+
+        case AP_BUCKET_EOS:
+            /* there is nothing to do here */
+            /* fallthru; n == 0 */
+            break;
+
+        default:
+            /* ### set some kind of error */
+            break;
+        }
+
+        if (n < 0)
+            check_first_conn_error(filter->r, "BUFF_filter_callback", 0);
+    }
+}
+
+API_EXPORT(void) ap_fc_write(ap_filter_t *filter, const char *buf,
+                             ap_size_t len)
+{
+    ap_filter_t *next;
+    ap_bucket_t bucket = { AP_BUCKET_PTRLEN, buf, len };
+
+    if (filter->r->connection->aborted || len == 0)
+        return;
+
+    if ((next = filter->next) == NULL) {
+        /* ### until we really put it into place */
+        BUFF_filter_callback(filter, &bucket);
+    }
+    else {
+        (*next->bucket_cb)(next, &bucket);
+    }
+}
+
+API_EXPORT(void) ap_fc_putc(ap_filter_t *filter, int c)
+{
+    ap_filter_t *next;
+    char c2 = (char)c;
+    ap_bucket_t bucket = { AP_BUCKET_PTRLEN, &c2, 1 };
+
+    if (filter->r->connection->aborted)
+        return;
+
+    if ((next = filter->next) == NULL) {
+        /* ### until we really put it into place */
+        BUFF_filter_callback(filter, &bucket);
+    }
+    else {
+        (*next->bucket_cb)(next, &bucket);
+    }
+}
+
+API_EXPORT(void) ap_fc_puts(ap_filter_t *filter, const char *str)
+{
+    ap_filter_t *next;
+    ap_bucket_t bucket = { AP_BUCKET_PTRLEN, str, strlen(str) };
+
+    if (filter->r->connection->aborted || *str == '\0')
+        return;
+
+    if ((next = filter->next) == NULL) {
+        /* ### until we really put it into place */
+        BUFF_filter_callback(filter, &bucket);
+    }
+    else {
+        (*next->bucket_cb)(next, &bucket);
+    }
+}
+
+API_EXPORT_NONSTD(void) ap_fc_putstrs(ap_filter_t *filter, ...)
+{
+    va_list va;
+
+    if (filter->r->connection->aborted)
+        return;
+
+    va_start(va, filter);
+    ap_fc_vputstrs(filter, va);
+    va_end(va);
+}
+
+API_EXPORT(void) ap_fc_vputstrs(ap_filter_t *filter, va_list va)
+{
+    ap_filter_t *next;
+    ap_bucket_t bucket = { AP_BUCKET_STRINGS, NULL, 0, NULL, va };
+
+    if (filter->r->connection->aborted)
+        return;
+
+    if ((next = filter->next) == NULL) {
+        /* ### until we really put it into place */
+        BUFF_filter_callback(filter, &bucket);
+    }
+    else {
+        (*next->bucket_cb)(next, &bucket);
+    }
+}
+
+API_EXPORT_NONSTD(void) ap_fc_printf(ap_filter_t *filter, const char *fmt, ...)
+{
+    va_list va;
+
+    if (filter->r->connection->aborted)
+        return;
+
+    va_start(va, fmt);
+    ap_fc_vprintf(filter, fmt, va);
+    va_end(va);
+}
+
+API_EXPORT(void) ap_fc_vprintf(ap_filter_t *filter,
+                               const char *fmt, va_list va)
+{
+    ap_filter_t *next;
+    ap_bucket_t bucket = { AP_BUCKET_PRINTF, NULL, 0, fmt, va };
+
+    if (filter->r->connection->aborted)
+        return;
+
+    if ((next = filter->next) == NULL) {
+        /* ### until we really put it into place */
+        BUFF_filter_callback(filter, &bucket);
+    }
+    else {
+        (*next->bucket_cb)(next, &bucket);
+    }
+}
+
+API_EXPORT(void) ap_fc_sendfile(ap_filter_t *filter, ap_file_t *file,
+                                ap_ssize_t flen)
+{
+    ap_filter_t *next;
+    ap_bucket_t bucket = {
+        AP_BUCKET_FILE, NULL, 0, NULL, NULL, file, flen
+    };
+
+    if (filter->r->connection->aborted || flen == 0)
+        return;
+
+    if ((next = filter->next) == NULL) {
+        /* ### until we really put it into place */
+        BUFF_filter_callback(filter, &bucket);
+    }
+    else {
+        (*next->bucket_cb)(next, &bucket);
+    }
+}
+
+API_EXPORT(void) ap_fc_putbucket(ap_filter_t *filter, ap_bucket_t *bucket)
+{
+    ap_filter_t *next;
+
+    if (filter->r->connection->aborted)
+        return;
+
+    if ((next = filter->next) == NULL) {
+        /* ### until we really put it into place */
+        BUFF_filter_callback(filter, bucket);
+    }
+    else {
+        (*next->bucket_cb)(next, bucket);
+    }
+}
+
 /* We should have named this send_canned_response, since it is used for any
  * response that can be generated by the server from the request record.
  * This includes all 204 (no content), 3xx (redirect), 4xx (client error),
@@ -2977,6 +3174,7 @@
     ap_finalize_request_protocol(r);
     ap_rflush(r);
 }
+
 
 AP_IMPLEMENT_HOOK_RUN_ALL(int,post_read_request,
                           (request_rec *r),(r),OK,DECLINED)
Index: main/http_request.c
===================================================================
RCS file: /home/cvs/apache-2.0/src/main/http_request.c,v
retrieving revision 1.35
diff -u -r1.35 http_request.c
--- main/http_request.c	2000/06/24 17:33:57	1.35
+++ main/http_request.c	2000/07/12 11:01:23
@@ -769,6 +769,9 @@
     rnew->htaccess       = r->htaccess;
     rnew->per_dir_config = r->server->lookup_defaults;
 
+    /* start with the same set of output filters */
+    rnew->filters = r->filters;
+
     ap_set_sub_req_protocol(rnew, r);
 
     /* would be nicer to pass "method" to ap_set_sub_req_protocol */
@@ -857,6 +860,9 @@
     rnew->htaccess       = r->htaccess;
     rnew->chunked        = r->chunked;
 
+    /* start with the same set of output filters */
+    rnew->filters = r->filters;
+
     ap_set_sub_req_protocol(rnew, r);
     fdir = ap_make_dirstr_parent(rnew->pool, r->filename);
 
@@ -960,16 +966,22 @@
 
 API_EXPORT(int) ap_run_sub_req(request_rec *r)
 {
-#ifndef APACHE_XLATE
-    int retval = ap_invoke_handler(r);
-#else /*APACHE_XLATE*/
-    /* Save the output conversion setting of the caller across subrequests */
     int retval;
-    ap_xlate_t *saved_xlate;
 
-    ap_bgetopt(r->connection->client, BO_WXLATE, &saved_xlate);
-    retval  = ap_invoke_handler(r);
-    ap_bsetopt(r->connection->client, BO_WXLATE, &saved_xlate);
+    /* see comments in process_request_internal() */
+    ap_run_insert_filter(r);
+
+#ifndef APACHE_XLATE
+    retval = ap_invoke_handler(r);
+#else /*APACHE_XLATE*/
+    {
+        /* Save the output conversion setting across subrequests */
+        ap_xlate_t *saved_xlate;
+
+        ap_bgetopt(r->connection->client, BO_WXLATE, &saved_xlate);
+        retval  = ap_invoke_handler(r);
+        ap_bsetopt(r->connection->client, BO_WXLATE, &saved_xlate);
+    }
 #endif /*APACHE_XLATE*/
     ap_finalize_sub_req_protocol(r);
     return retval;
Index: main/Makefile.in
===================================================================
RCS file: /home/cvs/apache-2.0/src/main/Makefile.in,v
retrieving revision 1.16
diff -u -r1.16 Makefile.in
--- main/Makefile.in	2000/07/01 14:14:15	1.16
+++ main/Makefile.in	2000/07/12 11:01:35
@@ -8,7 +8,7 @@
 	http_protocol.c http_request.c http_vhost.c util.c util_date.c \
 	util_script.c util_uri.c util_md5.c util_cfgtree.c util_ebcdic.c \
 	rfc1413.c http_connection.c iol_file.c iol_socket.c listen.c \
-        mpm_common.c util_charset.c util_debug.c util_xml.c
+        mpm_common.c util_charset.c util_debug.c util_xml.c filters.c
 
 include $(top_srcdir)/build/ltlib.mk
 
