Index: include/util_filter.h
===================================================================
RCS file: /home/cvs/apache-2.0/src/include/util_filter.h,v
retrieving revision 1.3
diff -u -r1.3 util_filter.h
--- include/util_filter.h	2000/08/05 04:38:57	1.3
+++ include/util_filter.h	2000/08/05 09:48:20
@@ -91,8 +91,40 @@
  * unterminated SSI directive).
  */
 
-/* forward declare the filter type */
+/*
+ * BUCKETS
+ *
+ * Filtering uses a "bucket" metaphor for holding content to be processed.
+ * These buckets may contain arbitrary types of data. The selection of the
+ * type is dependent upon how the "upstream" filter/generator places content
+ * into the filter chain stream.
+ *
+ * For example, if a content generator uses ap_rwrite(), then the data will
+ * be placed into an AP_BUCKET_PTRLEN bucket. This bucket type contains a
+ * single pointer/length pair which will refer to the data.
+ *
+ * Buckets types are defined around the need to avoid copying the data if
+ * at all possible. Whatever the "natural" input form is for a piece of
+ * content, this is modelled within the bucket types. For example, when a
+ * content generator uses ap_rprintf() or a filter uses ap_fc_printf(),
+ * the format string and arguments are fed into/down the filter chain as
+ * just theat: a format string and its arguments. The filter mechanism avoids
+ * reducing the format/args to a final string for as long as possible. At
+ * some point, a filter or the output of the chain will combine these to
+ * produce actual bytes, but it is most optimal to defer this until it is
+ * truly needed.
+ *
+ * See the ap_bucket_type enumeration for the different bucket types which
+ * are currently defined.
+ *
+ * Buckets may also be linked into a list so that they may be passed as
+ * entire groups of content. The filter may insert/remove/replace the buckets
+ * within this list before passing the list to the next filter.
+ */
+
+/* forward declare some types */
 typedef struct ap_filter_t ap_filter_t;
+typedef struct ap_bucket_t ap_bucket_t;
 
 /*
  * ap_filter_func:
@@ -114,7 +146,7 @@
  * next/prev to insert/remove/replace elements in the bucket list, but
  * the types and values of the individual buckets should not be altered.
  */
-typedef apr_status_t (*ap_filter_func)();
+typedef void (*ap_filter_func)(ap_filter_t *filter, ap_bucket_t *bucket);
 
 /*
  * ap_filter_type:
@@ -161,12 +193,155 @@
  */
 struct ap_filter_t {
     ap_filter_func filter_func;
+    request_rec *r;
 
     void *ctx;
 
     ap_filter_type ftype;
     ap_filter_t *next;
 };
+
+/*
+ * ap_bucket_type:
+ *
+ * This enumeration is used to specify what type of bucket is present when
+ * an ap_bucket_t is provided.
+ *
+ * AP_BUCKET_PTRLEN:
+ *     This bucket type defines a simple pointer/length pair for the content.
+ *     The content is NOT necessarily null-terminated.
+ *
+ *     This type occurs when ap_rwrite(), ap_fc_write(), ap_rputs(),
+ *     ap_fc_puts(), ap_rputc(), or ap_fc_putc() is used by the upstream
+ *     filter/generator.
+ *
+ * AP_BUCKET_STRINGS:
+ *     This bucket type defines a set of null-terminated strings. The actual
+ *     representation is through varargs' va_list type. A filter can sequence
+ *     through the arguments using the va_arg() macro (and the "const char *"
+ *     type). The filter should NOT use va_start() or va_end(). When va_arg()
+ *     returns a NULL pointer, the list of strings is complete.
+ *
+ *     Note that you can only sequence through the strings once, due to the
+ *     definition of va_list. Thus, the first filter to do this sequencing
+ *     must pass the resulting content to the next filter in a new form (the
+ *     bucket cannot simply be passed because ->va is useless).
+ *
+ *     This type occurs when ap_rvputs(), ap_fc_putstrs, or ap_fc_vputstrs()
+ *     is used by the upstream filter/generator.
+ *
+ * AP_BUCKET_PRINTF:
+ *     This bucket type defines a printf-style format and arguments. Similar
+ *     to AP_BUCKET_STRINGS, this type also uses the ->va field to refer to
+ *     the arguments. The format for the printf is stored in ->fmt.
+ *
+ *     Also similar to AP_BUCKET_STRINGS, the va_start/va_end macros should
+ *     not be used, and ->va should be processed only once. The bucket may
+ *     not be passed after this processing.
+ *
+ *     This type occurs when ap_rprintf(), ap_vrprintf(), ap_fc_printf(), or
+ *     ap_fc_vprintf() is used by the upstream filter/generator.
+ *
+ * AP_BUCKET_FILE:
+ *     This bucket type refers to an open file, from the current position
+ *     and extending for ->flen bytes. Since there are some ap_file_t
+ *     implementations/types that are not seekable, it may be impossible to
+ *     "rewind" the file's current position after reading the contenxt.
+ *     Therefore, it is important to note that once the content has been
+ *     read, it must be passed to the next filter in a different form.
+ *
+ *     Note: if there is a way to determine whether a file is seekable, then
+ *     it would be legal to fetch the current position, read the contents,
+ *     rewind to the original position, and then pass this bucket/file down
+ *     to the next filter in the output chain.
+ *
+ *     This type occurs when ap_send_fd(), ap_send_fd_length(), or
+ *     ap_fc_sendfile() are used by the upstream filter/generator.
+ *
+ * AP_BUCKET_EOS:
+ *     This bucket signals the end of the content stream. The filter should
+ *     flush any internal state and issue errors if the state specifies that
+ *     and end of stream cannot occur now (e.g. a command directive is
+ *     incomplete).
+ *
+ *     This type occurs when Apache finalizes a (sub)request, or when an
+ *     upstream filter passes this bucket along.
+ */
+typedef enum {
+    AP_BUCKET_PTRLEN,
+    AP_BUCKET_STRINGS,
+    AP_BUCKET_PRINTF,
+    AP_BUCKET_FILE,
+    AP_BUCKET_EOS
+} ap_bucket_type;
+
+/*
+ * ap_bucket_t:
+ *
+ * The actual bucket definition. The type is determined by the ->type field.
+ * Which fields are valid/useful in the bucket is determined by the type,
+ * as noted below and in the comments above for each type.
+ *
+ * Buckets are arranged in a doubly-linked list so that a filter may insert,
+ * remove, or replace elements in a list of buckets. Generally, a filter
+ * should not change any bucket values other than these link pointers.
+ */
+struct ap_bucket_t {
+    ap_bucket_type type;
+
+    const char *buf;            /* AP_BUCKET_PTRLEN */
+    apr_size_t len;             /* AP_BUCKET_PTRLEN */
+
+    const char *fmt;            /* AP_BUCKET_PRINTF */
+    va_list va;                 /* AP_BUCKET_STRINGS, _PRINTF */
+
+    apr_file_t *file;           /* AP_BUCKET_FILE */
+    apr_ssize_t flen;           /* AP_BUCKET_FILE */
+
+    ap_bucket_t *next;          /* next bucket in list */
+    ap_bucket_t *prev;          /* previous bucket in list */
+};
+
+/*
+ * FILTER CHAIN OUTPUT FUNCTIONS
+ *
+ * These functions are used to deliver output/content down to the next
+ * filter in the chain.
+ *
+ * ap_fc_write(): write a block of bytes
+ * ap_fc_putc(): write a single character
+ * ap_fc_puts(): write a null-terminated string
+ * ap_fc_putstrs(): write a set of null-termianted strings; the end is
+ *                  signaled by a NULL parameter
+ * ap_fc_vputstrs(): same as ap_fc_putstrs(), but where the set of strings
+ *                   is defined by a va_list
+ * ap_fc_printf(): use printf-like semantics for writing a string
+ * ap_fc_vprintf(): use printf-like semantics, but with a va_list for the args
+ * ap_fc_sendfile(): send the file contents, from the current file position,
+ *                   and extending for "len" bytes; AP_FC_SENDFILE_ALL is
+ *                   used to send from current-position to the end-of-file.
+ * ap_fc_putbucket(): write a bucket into the filter chain
+ */
+API_EXPORT(void) ap_fc_write(ap_filter_t *filter, const char *buf,
+                             apr_size_t len);
+API_EXPORT(void) ap_fc_putc(ap_filter_t *filter, int c);
+API_EXPORT(void) ap_fc_puts(ap_filter_t *filter, const char *str);
+
+API_EXPORT_NONSTD(void) ap_fc_putstrs(ap_filter_t *filter, ...);
+API_EXPORT(void) ap_fc_vputstrs(ap_filter_t *filter, va_list va);
+
+API_EXPORT_NONSTD(void) ap_fc_printf(ap_filter_t *filter,
+                                     const char *fmt, ...);
+API_EXPORT(void) ap_fc_vprintf(ap_filter_t *filter,
+                               const char *fmt, va_list va);
+
+API_EXPORT(void) ap_fc_sendfile(ap_filter_t *filter, apr_file_t *file,
+                                apr_ssize_t flen);
+#define AP_FC_SENDFILE_ALL ((apr_ssize_t) -1)
+
+/* note: bucket->next and ->prev may be changed upon return from this */
+API_EXPORT(void) ap_fc_putbucket(ap_filter_t *filter, ap_bucket_t *bucket);
+
 
 /*
  * ap_register_filter():
Index: main/http_protocol.c
===================================================================
RCS file: /home/cvs/apache-2.0/src/main/http_protocol.c,v
retrieving revision 1.100
diff -u -r1.100 http_protocol.c
--- main/http_protocol.c	2000/08/02 05:26:48	1.100
+++ main/http_protocol.c	2000/08/05 09:48:23
@@ -77,6 +77,7 @@
                                  * support code... */
 #include "util_date.h"          /* For parseHTTPdate and BAD_DATE */
 #include "util_charset.h"
+#include "util_filter.h"
 #include "mpm_status.h"
 #ifdef APR_HAVE_STDARG_H
 #include <stdarg.h>
@@ -100,7 +101,10 @@
           ap_bgetopt (r->connection->client, BO_BYTECT, &r->bytes_sent); \
   } while (0)
 
+#define DECL_FILTER_HEAD(r, f) \
+    ap_filter_t f = { NULL, (r), NULL, 0, (r)->filters }
 
+
 /* if this is the first error, then log an INFO message and shut down the
  * connection.
  */
@@ -407,6 +411,9 @@
 
 API_EXPORT(int) ap_set_content_length(request_rec *r, long clength)
 {
+    if (r->filters != NULL)
+        return 0;
+
     r->clength = clength;
     apr_table_setn(r->headers_out, "Content-Length", apr_psprintf(r->pool, "%ld", clength));
     return 0;
@@ -1280,10 +1287,10 @@
 
 static void end_output_stream(request_rec *r)
 {
-    /*
-    ** ### place holder to tell filters that no more content will be
-    ** ### arriving. typically, they will flush any pending content
-    */
+    DECL_FILTER_HEAD(r, filter);
+    ap_bucket_t bucket = { AP_BUCKET_EOS };
+
+    ap_fc_putbucket(&filter, &bucket);
 }
 
 void ap_finalize_sub_req_protocol(request_rec *sub)
@@ -2501,107 +2508,88 @@
 
 API_EXPORT(int) ap_rputc(int c, request_rec *r)
 {
+    DECL_FILTER_HEAD(r, filter);
+
     if (r->connection->aborted)
         return EOF;
 
-    if (ap_bputc(c, r->connection->client) < 0) {
-        check_first_conn_error(r, "rputc", 0);
-        return EOF;
-    }
+    ap_fc_putc(&filter, c);
+
     SET_BYTES_SENT(r);
-    return c;
+    return 1;
 }
 
 API_EXPORT(int) ap_rputs(const char *str, request_rec *r)
 {
-    int rcode;
+    DECL_FILTER_HEAD(r, filter);
 
     if (r->connection->aborted)
         return EOF;
     
-    rcode = ap_bputs(str, r->connection->client);
-    if (rcode < 0) {
-        check_first_conn_error(r, "rputs", 0);
-        return EOF;
-    }
+    ap_fc_puts(&filter, str);
+
     SET_BYTES_SENT(r);
-    return rcode;
+    return 1;
 }
 
 API_EXPORT(int) ap_rwrite(const void *buf, int nbyte, request_rec *r)
 {
-    apr_ssize_t n;
-    apr_status_t rv;
+    DECL_FILTER_HEAD(r, filter);
 
     if (r->connection->aborted)
         return EOF;
 
-    /* ### should loop to avoid partial writes */
-    rv = ap_bwrite(r->connection->client, buf, nbyte, &n);
-    if (rv != APR_SUCCESS) {
-        check_first_conn_error(r, "rwrite", rv);
-        return EOF;
-    }
+    ap_fc_write(&filter, buf, nbyte);
+
     SET_BYTES_SENT(r);
-    return n;
+    return nbyte;
 }
 
 API_EXPORT(int) ap_vrprintf(request_rec *r, const char *fmt, va_list va)
 {
-    int n;
+    DECL_FILTER_HEAD(r, filter);
 
     if (r->connection->aborted)
         return EOF;
 
-    n = ap_vbprintf(r->connection->client, fmt, va);
+    ap_fc_vprintf(&filter, fmt, va);
 
-    if (n < 0) {
-        check_first_conn_error(r, "vrprintf", 0);
-        return EOF;
-    }
     SET_BYTES_SENT(r);
-    return n;
+    return 1;
 }
 
 API_EXPORT_NONSTD(int) ap_rprintf(request_rec *r, const char *fmt, ...)
 {
     va_list va;
-    int n;
 
+    DECL_FILTER_HEAD(r, filter);
+
     if (r->connection->aborted)
         return EOF;
 
     va_start(va, fmt);
-    n = ap_vbprintf(r->connection->client, fmt, va);
+    ap_fc_vprintf(&filter, fmt, va);
     va_end(va);
 
-    if (n < 0) {
-        check_first_conn_error(r, "rprintf", 0);
-        return EOF;
-    }
     SET_BYTES_SENT(r);
-    return n;
+    return 1;
 }
 
 API_EXPORT_NONSTD(int) ap_rvputs(request_rec *r, ...)
 {
     va_list va;
-    int n;
+
+    DECL_FILTER_HEAD(r, filter);
 
     if (r->connection->aborted)
         return EOF;
 
     va_start(va, r);
-    n = ap_vbputstrs(r->connection->client, va);
+    ap_fc_vputstrs(&filter, va);
     va_end(va);
 
-    if (n < 0) {
-        check_first_conn_error(r, "rvputs", 0);
-        return EOF;
-    }
-
     SET_BYTES_SENT(r);
-    return n;
+    return 1;
 }
 
 API_EXPORT(int) ap_rflush(request_rec *r)
@@ -2615,6 +2603,210 @@
     return 0;
 }
 
+static void BUFF_filter_callback(ap_filter_t *filter, ap_bucket_t *bucket)
+{
+    ap_bucket_t *bscan = bucket;
+
+    for (bscan = bucket; bscan != NULL; bscan = bscan->next) {
+        int n = 0;
+
+        switch (bscan->type) {
+        case AP_BUCKET_PTRLEN:
+            if (bscan->len == 1) {
+                n = ap_bputc(*bscan->buf, filter->r->connection->client);
+            }
+            else {
+                apr_status_t rv;
+                apr_ssize_t written;
+
+                /* ### should loop to ensure everything is written */
+                rv = ap_bwrite(filter->r->connection->client, bscan->buf,
+                               bscan->len, &written);
+                if (rv != APR_SUCCESS) {
+                    check_first_conn_error(filter->r, "BUFF_filter_callback",
+                                           rv);
+                }
+                /* fallthru; n == 0 */
+            }
+            break;
+
+        case AP_BUCKET_STRINGS:
+            n = ap_vbputstrs(filter->r->connection->client, bscan->va);
+            break;
+
+        case AP_BUCKET_PRINTF:
+            n = ap_vbprintf(filter->r->connection->client, bscan->fmt,
+                            bscan->va);
+            break;
+
+        case AP_BUCKET_FILE:
+            /* ### fill in file case */
+            /* ### fallthru; n == 0 */
+            break;
+
+        case AP_BUCKET_EOS:
+            /* there is nothing to do here */
+            /* fallthru; n == 0 */
+            break;
+
+        default:
+            /* ### set some kind of error */
+            break;
+        }
+
+        if (n < 0)
+            check_first_conn_error(filter->r, "BUFF_filter_callback", 0);
+    }
+}
+
+API_EXPORT(void) ap_fc_write(ap_filter_t *filter, const char *buf,
+                             apr_size_t len)
+{
+    ap_filter_t *next;
+    ap_bucket_t bucket = { AP_BUCKET_PTRLEN, buf, len };
+
+    if (filter->r->connection->aborted || len == 0)
+        return;
+
+    if ((next = filter->next) == NULL) {
+        /* ### until we really put it into place */
+        BUFF_filter_callback(filter, &bucket);
+    }
+    else {
+        (*next->filter_func)(next, &bucket);
+    }
+}
+
+API_EXPORT(void) ap_fc_putc(ap_filter_t *filter, int c)
+{
+    ap_filter_t *next;
+    char c2 = (char)c;
+    ap_bucket_t bucket = { AP_BUCKET_PTRLEN, &c2, 1 };
+
+    if (filter->r->connection->aborted)
+        return;
+
+    if ((next = filter->next) == NULL) {
+        /* ### until we really put it into place */
+        BUFF_filter_callback(filter, &bucket);
+    }
+    else {
+        (*next->filter_func)(next, &bucket);
+    }
+}
+
+API_EXPORT(void) ap_fc_puts(ap_filter_t *filter, const char *str)
+{
+    ap_filter_t *next;
+    ap_bucket_t bucket = { AP_BUCKET_PTRLEN, str, strlen(str) };
+
+    if (filter->r->connection->aborted || *str == '\0')
+        return;
+
+    if ((next = filter->next) == NULL) {
+        /* ### until we really put it into place */
+        BUFF_filter_callback(filter, &bucket);
+    }
+    else {
+        (*next->filter_func)(next, &bucket);
+    }
+}
+
+API_EXPORT_NONSTD(void) ap_fc_putstrs(ap_filter_t *filter, ...)
+{
+    va_list va;
+
+    if (filter->r->connection->aborted)
+        return;
+
+    va_start(va, filter);
+    ap_fc_vputstrs(filter, va);
+    va_end(va);
+}
+
+API_EXPORT(void) ap_fc_vputstrs(ap_filter_t *filter, va_list va)
+{
+    ap_filter_t *next;
+    ap_bucket_t bucket = { AP_BUCKET_STRINGS, NULL, 0, NULL, va };
+
+    if (filter->r->connection->aborted)
+        return;
+
+    if ((next = filter->next) == NULL) {
+        /* ### until we really put it into place */
+        BUFF_filter_callback(filter, &bucket);
+    }
+    else {
+        (*next->filter_func)(next, &bucket);
+    }
+}
+
+API_EXPORT_NONSTD(void) ap_fc_printf(ap_filter_t *filter, const char *fmt, ...)
+{
+    va_list va;
+
+    if (filter->r->connection->aborted)
+        return;
+
+    va_start(va, fmt);
+    ap_fc_vprintf(filter, fmt, va);
+    va_end(va);
+}
+
+API_EXPORT(void) ap_fc_vprintf(ap_filter_t *filter,
+                               const char *fmt, va_list va)
+{
+    ap_filter_t *next;
+    ap_bucket_t bucket = { AP_BUCKET_PRINTF, NULL, 0, fmt, va };
+
+    if (filter->r->connection->aborted)
+        return;
+
+    if ((next = filter->next) == NULL) {
+        /* ### until we really put it into place */
+        BUFF_filter_callback(filter, &bucket);
+    }
+    else {
+        (*next->filter_func)(next, &bucket);
+    }
+}
+
+API_EXPORT(void) ap_fc_sendfile(ap_filter_t *filter, apr_file_t *file,
+                                apr_ssize_t flen)
+{
+    ap_filter_t *next;
+    ap_bucket_t bucket = {
+        AP_BUCKET_FILE, NULL, 0, NULL, NULL, file, flen
+    };
+
+    if (filter->r->connection->aborted || flen == 0)
+        return;
+
+    if ((next = filter->next) == NULL) {
+        /* ### until we really put it into place */
+        BUFF_filter_callback(filter, &bucket);
+    }
+    else {
+        (*next->filter_func)(next, &bucket);
+    }
+}
+
+API_EXPORT(void) ap_fc_putbucket(ap_filter_t *filter, ap_bucket_t *bucket)
+{
+    ap_filter_t *next;
+
+    if (filter->r->connection->aborted)
+        return;
+
+    if ((next = filter->next) == NULL) {
+        /* ### until we really put it into place */
+        BUFF_filter_callback(filter, bucket);
+    }
+    else {
+        (*next->filter_func)(next, bucket);
+    }
+}
+
 /* We should have named this send_canned_response, since it is used for any
  * response that can be generated by the server from the request record.
  * This includes all 204 (no content), 3xx (redirect), 4xx (client error),
@@ -3003,6 +3195,7 @@
     ap_finalize_request_protocol(r);
     ap_rflush(r);
 }
+
 
 AP_IMPLEMENT_HOOK_RUN_ALL(int,post_read_request,
                           (request_rec *r),(r),OK,DECLINED)
Index: main/util_filter.c
===================================================================
RCS file: /home/cvs/apache-2.0/src/main/util_filter.c,v
retrieving revision 1.3
diff -u -r1.3 util_filter.c
--- main/util_filter.c	2000/08/05 04:38:58	1.3
+++ main/util_filter.c	2000/08/05 09:48:23
@@ -126,6 +126,7 @@
             f->filter_func = frec->filter_func;
             f->ctx = ctx;
             f->ftype = frec->ftype;
+            f->r = r;
 
             if (INSERT_BEFORE(f, r->filters)) {
                 f->next = r->filters;
