? include/util_filter.h
? lib/apr/buckets/Makefile.in
? lib/apr/include/apr_buf.h
? main/util_filter.c
Index: ap/Makefile.in
===================================================================
RCS file: /home/cvs/apache-2.0/src/ap/Makefile.in,v
retrieving revision 1.4
diff -u -d -b -w -u -r1.4 Makefile.in
--- ap/Makefile.in	2000/06/12 20:41:13	1.4
+++ ap/Makefile.in	2000/07/17 23:40:28
@@ -1,5 +1,5 @@
 
 LTLIBRARY_NAME    = libap.la
-LTLIBRARY_SOURCES = ap_cache.c ap_base64.c ap_sha1.c ap_buf.c ap_hooks.c
+LTLIBRARY_SOURCES = ap_cache.c ap_base64.c ap_sha1.c ap_hooks.c 
 
 include $(top_srcdir)/build/ltlib.mk
Index: include/ap_iol.h
===================================================================
RCS file: /home/cvs/apache-2.0/src/include/ap_iol.h,v
retrieving revision 1.19
diff -u -d -b -w -u -r1.19 ap_iol.h
--- include/ap_iol.h	2000/05/29 04:22:02	1.19
+++ include/ap_iol.h	2000/07/17 23:40:31
@@ -58,6 +58,7 @@
 #define AP_IOL_H
 
 #include "apr_general.h" /* For ap_s?size_t */
+#include "apr_network_io.h" /* For ap_hdtr_t */
 #include "apr_errno.h" /* For ap_status_t and the APR_errnos */
 
 typedef struct ap_iol ap_iol;
Index: include/http_protocol.h
===================================================================
RCS file: /home/cvs/apache-2.0/src/include/http_protocol.h,v
retrieving revision 1.19
diff -u -d -b -w -u -r1.19 http_protocol.h
--- include/http_protocol.h	2000/07/11 03:48:17	1.19
+++ include/http_protocol.h	2000/07/17 23:40:31
@@ -89,8 +89,15 @@
 API_EXPORT(void) ap_basic_http_header(request_rec *r);
 
 /* Send the Status-Line and header fields for HTTP response */
+API_EXPORT(void) ap_send_http_header_real(request_rec *l);
 
-API_EXPORT(void) ap_send_http_header(request_rec *l);
+/* this is the old function that used to send headers to the network.  We
+ * don't want handlers using it anymore, becuase the filter that actually
+ * writes to the network has to send the headers.  I am defining it to be
+ * NULL, because everybody seems to want to not break existing modules.
+ * The new function ap_send_http_header_real() actually sends the data.
+ */
+#define ap_send_http_header(l)   /* No-op*/ 
 
 /* Send the response to special method requests */
 
Index: include/httpd.h
===================================================================
RCS file: /home/cvs/apache-2.0/src/include/httpd.h,v
retrieving revision 1.64
diff -u -d -b -w -u -r1.64 httpd.h
--- include/httpd.h	2000/06/30 21:18:13	1.64
+++ include/httpd.h	2000/07/17 23:40:32
@@ -596,6 +596,11 @@
 				 * pointer back to the main request.
 				 */
 
+    ap_array_header_t *filters; /* The array of filters to call */
+    int headers_sent;           /* Have we sent the headers for this request
+                                 * yet.
+                                 */
+
     /* Info about the request itself... we begin with stuff that only
      * protocol.c should ever touch...
      */
Index: lib/apr/configure.in
===================================================================
RCS file: /home/cvs/apache-2.0/src/lib/apr/configure.in,v
retrieving revision 1.136
diff -u -d -b -w -u -r1.136 configure.in
--- lib/apr/configure.in	2000/07/15 15:39:05	1.136
+++ lib/apr/configure.in	2000/07/17 23:40:32
@@ -682,8 +682,8 @@
 AC_SUBST(EXEEXT)
 
 echo "Construct Makefiles and header files."
-MAKEFILE1="Makefile lib/Makefile "
-SUBDIRS="lib "
+MAKEFILE1="Makefile lib/Makefile buckets/Makefile"
+SUBDIRS="lib buckets"
 for dir in $MODULES
 do
     test -d $dir || $MKDIR -p $dir
Index: lib/apr/buckets/ap_buf.c
===================================================================
RCS file: /home/cvs/apache-2.0/src/lib/apr/buckets/ap_buf.c,v
retrieving revision 1.12
diff -u -d -b -w -u -r1.12 ap_buf.c
--- lib/apr/buckets/ap_buf.c	2000/07/14 00:24:33	1.12
+++ lib/apr/buckets/ap_buf.c	2000/07/17 23:40:33
@@ -100,10 +100,25 @@
 APR_EXPORT(ap_status_t) ap_bucket_brigade_destroy(void *data)
 {
     ap_bucket_brigade *b = data;
-    ap_bucket_list *bl = b->head;
 
-    ap_destroy_bucket_list(bl);
+    ap_bucket_list_destroy(b->head);
+    /* The brigade itself is allocated out of a pool, so we don't actually 
+     * want to free it.  If we did, we would do that free() here.
+     */
+
+    return APR_SUCCESS;
+}
+
+APR_EXPORT(ap_status_t) ap_bucket_list_destroy(ap_bucket *e)
+{
+    ap_bucket *cur = e;
+    ap_bucket *next;
 
+    while (cur) {
+        next = cur->next;
+        ap_bucket_destroy(cur);
+        cur = next;
+    }
     return APR_SUCCESS;
 }        
 
@@ -120,18 +135,10 @@
     return b;
 }
 
-APR_EXPORT(ap_bucket_list *) ap_bucket_list_create(void)
-{
-    ap_bucket_list *b;
-    
-    b = calloc(1, sizeof(*b));
-    return b;
-}
-
-APR_EXPORT(void) ap_bucket_brigade_append_list(ap_bucket_brigade *b, 
-                                               ap_bucket_list *e)
+APR_EXPORT(void) ap_bucket_brigade_append_buckets(ap_bucket_brigade *b, 
+                                                  ap_bucket *e)
 {
-    ap_bucket_list *cur = e;
+    ap_bucket *cur = e;
 
     if (b->tail) {
         b->tail->next = e;
@@ -146,37 +153,17 @@
     }
 }
 
-APR_EXPORT(void) ap_bucket_brigade_append_bucket(ap_bucket_brigade *b,
-                                                 ap_bucket *r)
-{
-    if (b->tail) {
-        if (b->tail->bucket == NULL) {
-            b->tail->bucket = r;
-        }
-        else {
-            b->tail->next = ap_bucket_list_create();
-            b->tail->next->prev = b->tail;
-            b->tail = b->tail->next;
-            b->tail->bucket = r;
-        }
-    }
-    else {
-        b->head = b->tail = ap_bucket_list_create();
-        b->tail->bucket = r;
-    }
-}
-
 APR_EXPORT(int) ap_bucket_brigade_to_iovec(ap_bucket_brigade *b, 
                                            struct iovec *vec, int nvec)
 {
-    ap_bucket_list *e;
+    ap_bucket *e;
     struct iovec *orig;
 
     orig = vec;
     e = b->head;
     while (e && nvec) {
-	vec->iov_base = (void *)ap_get_bucket_char_str(e->bucket);
-	vec->iov_len = ap_get_bucket_len(e->bucket);
+	vec->iov_base = (void *)ap_get_bucket_char_str(e);
+	vec->iov_len = ap_get_bucket_len(e);
 	e = e->next;
 	--nvec;
 	++vec;
@@ -207,12 +194,12 @@
 
     for (i=0; i < nvec; i++) {
         if (b->head == b->tail) {
-            ap_bucket_destroy(b->head->bucket);
+            ap_bucket_destroy(b->head);
             b->head = b->tail = NULL;
             break;
         }
         b->head = b->head->next;
-        ap_bucket_destroy(b->head->prev->bucket);
+        ap_bucket_destroy(b->head->prev);
         b->head->prev = NULL;
     }
 }
@@ -241,17 +228,6 @@
     return APR_SUCCESS;
 }
 
-APR_EXPORT(ap_status_t) ap_destroy_bucket_list(ap_bucket_list *buf)
-{
-    ap_bucket_list *dptr = buf;
-   
-    while (dptr) {
-        ap_bucket_destroy(dptr->bucket);
-        dptr = dptr->next;
-    }
-    return APR_SUCCESS;
-}
-
 APR_EXPORT(const char *) ap_get_bucket_char_str(ap_bucket *b)
 {
     if (b) {
@@ -275,10 +251,9 @@
     int j, k, rv;
     ap_ssize_t i;
 
-    if (b->tail && b->tail->bucket && 
-        b->tail->bucket->color == AP_BUCKET_rwmem) {
+    if (b->tail && b->tail->color == AP_BUCKET_rwmem) {
         ap_bucket *rw;
-        rw = b->tail->bucket;
+        rw = b->tail;
         /* I have no idea if this is a good idea or not.  Probably not.
          * Basically, if the last bucket in the list is a rwmem bucket,
          * then we just add to it instead of allocating a new read only
@@ -298,7 +273,7 @@
             }
             k += i;
 
-            ap_bucket_brigade_append_bucket(b, rw);
+            ap_bucket_brigade_append_buckets(b, rw);
         }        
     }
     
@@ -316,7 +291,7 @@
         }
         k += i;
 
-        ap_bucket_brigade_append_bucket(b, r);
+        ap_bucket_brigade_append_buckets(b, r);
     }
 
     return k;
@@ -346,7 +321,7 @@
 
     r = ap_bucket_new(AP_BUCKET_rwmem);
     res = r->insert(r, buf, strlen(buf), &i);
-    ap_bucket_brigade_append_bucket(b, r);
+    ap_bucket_brigade_append_buckets(b, r);
 
     return res;
 }
Index: lib/apr/buckets/ap_eos_buf.c
===================================================================
RCS file: /home/cvs/apache-2.0/src/lib/apr/buckets/ap_eos_buf.c,v
retrieving revision 1.1
diff -u -d -b -w -u -r1.1 ap_eos_buf.c
--- lib/apr/buckets/ap_eos_buf.c	2000/07/13 21:48:33	1.1
+++ lib/apr/buckets/ap_eos_buf.c	2000/07/17 23:40:33
@@ -73,7 +73,7 @@
 {
     ap_bucket *newbuf;
 
-    newbuf            = malloc(sizeof(*newbuf));
+    newbuf            = calloc(1, sizeof(*newbuf));
 
     newbuf->color     = AP_BUCKET_eos;
     newbuf->getstr    = eos_get_str;
Index: lib/apr/buckets/ap_mmap_buf.c
===================================================================
RCS file: /home/cvs/apache-2.0/src/lib/apr/buckets/ap_mmap_buf.c,v
retrieving revision 1.4
diff -u -d -b -w -u -r1.4 ap_mmap_buf.c
--- lib/apr/buckets/ap_mmap_buf.c	2000/07/14 00:24:33	1.4
+++ lib/apr/buckets/ap_mmap_buf.c	2000/07/17 23:40:33
@@ -89,7 +89,7 @@
     ap_bucket *newbuf;
     ap_bucket_mmap *b;
 
-    newbuf            = malloc(sizeof(*newbuf));
+    newbuf            = calloc(1, sizeof(*newbuf));
     b                 = malloc(sizeof(*b));
 
     b->data      = NULL;
Index: lib/apr/buckets/ap_rmem_buf.c
===================================================================
RCS file: /home/cvs/apache-2.0/src/lib/apr/buckets/ap_rmem_buf.c,v
retrieving revision 1.5
diff -u -d -b -w -u -r1.5 ap_rmem_buf.c
--- lib/apr/buckets/ap_rmem_buf.c	2000/07/14 00:24:33	1.5
+++ lib/apr/buckets/ap_rmem_buf.c	2000/07/17 23:40:33
@@ -106,7 +106,7 @@
     ap_bucket *newbuf;
     ap_bucket_rmem *b;
 
-    newbuf                = malloc(sizeof(*newbuf));
+    newbuf                = calloc(1, sizeof(*newbuf));
     b                     = malloc(sizeof(*b)); 
 
     b->alloc_len          = 0;
Index: lib/apr/buckets/ap_rwmem_buf.c
===================================================================
RCS file: /home/cvs/apache-2.0/src/lib/apr/buckets/ap_rwmem_buf.c,v
retrieving revision 1.5
diff -u -d -b -w -u -r1.5 ap_rwmem_buf.c
--- lib/apr/buckets/ap_rwmem_buf.c	2000/07/14 00:24:33	1.5
+++ lib/apr/buckets/ap_rwmem_buf.c	2000/07/17 23:40:33
@@ -124,7 +124,7 @@
     ap_bucket *newbuf;
     ap_bucket_rwmem *b;
 
-    newbuf = malloc(sizeof(*newbuf));
+    newbuf = calloc(1, sizeof(*newbuf));
     b = malloc(sizeof(*b));
     
     b->alloc_addr = calloc(DEFAULT_RWBUF_SIZE, 1);
Index: lib/apr/buckets/apr_buf.h
===================================================================
RCS file: /home/cvs/apache-2.0/src/lib/apr/buckets/apr_buf.h,v
retrieving revision 1.13
diff -u -d -b -w -u -r1.13 apr_buf.h
--- lib/apr/buckets/apr_buf.h	2000/07/14 00:24:33	1.13
+++ lib/apr/buckets/apr_buf.h	2000/07/17 23:40:33
@@ -95,13 +95,8 @@
      * into the bucket.
      */ 
     int (*insert)(ap_bucket *e, const void *buf, ap_size_t nbytes, ap_ssize_t *w);
-};
-
-typedef struct ap_bucket_list ap_bucket_list;
-struct ap_bucket_list {
-    ap_bucket *bucket;                   /* The bucket */
-    ap_bucket_list *next;                /* The next node in the bucket list */
-    ap_bucket_list *prev;                /* The prev node in the bucket list */
+    ap_bucket *next;                     /* The next node in the bucket list */
+    ap_bucket *prev;                     /* The prev node in the bucket list */
 };
 
 typedef struct ap_bucket_brigade ap_bucket_brigade;
@@ -111,8 +106,8 @@
                                            but this lets me register a cleanup
                                            to put a limit on the brigade's 
                                            lifetime. */
-    ap_bucket_list *head;               /* The start of the brigade */
-    ap_bucket_list *tail;               /* The end of the brigade */
+    ap_bucket *head;                    /* The start of the brigade */
+    ap_bucket *tail;                    /* The end of the brigade */
 };
 
 /*    ******  Different bucket types   *****/
@@ -151,14 +146,10 @@
 
 /* destroy an enitre bucket brigade */
 APR_EXPORT(ap_status_t) ap_bucket_brigade_destroy(void *b);
-
-/* append a bucket_list to a bucket_brigade */
-APR_EXPORT(void) ap_bucket_brigade_append_list(ap_bucket_brigade *b, 
-                                               ap_bucket_list *e);
 
-/* append a bucket to a bucket_brigade */
-APR_EXPORT(void) ap_bucket_brigade_append_bucket(ap_bucket_brigade *b,
-                                                 ap_bucket *r);
+/* append bucket(s) to a bucket_brigade */
+APR_EXPORT(void) ap_bucket_brigade_append_buckets(ap_bucket_brigade *b,
+                                                  ap_bucket *e);
 
 /* consume nbytes from beginning of b -- call ap_bucket_destroy as
     appropriate, and/or modify start on last element */
@@ -189,14 +180,6 @@
 
 APR_EXPORT(int) ap_brigade_vprintf(ap_bucket_brigade *b, const char *fmt, va_list va);
 
-/*   ******  Bucket List Functions  *****  */
-
-/* create a new bucket_list */
-APR_EXPORT(ap_bucket_list *) ap_bucket_list_create(void);
-
-/* destroy an entire bucket_list */
-APR_EXPORT(ap_status_t) ap_destroy_bucket_list(ap_bucket_list *b);
-
 /*   ******  Bucket Functions  *****  */
 
 /* allocate a bucket of type color */
@@ -204,6 +187,9 @@
 
 /* destroy a bucket */
 APR_EXPORT(ap_status_t) ap_bucket_destroy(ap_bucket *e);
+
+/* destroy an entire list of buckets */
+APR_EXPORT(ap_status_t) ap_bucket_list_destroy(ap_bucket *e);
 
 /* Convert a bucket to a char * */
 APR_EXPORT(const char *) ap_get_bucket_char_str(ap_bucket *b);
Index: main/Makefile.in
===================================================================
RCS file: /home/cvs/apache-2.0/src/main/Makefile.in,v
retrieving revision 1.16
diff -u -d -b -w -u -r1.16 Makefile.in
--- main/Makefile.in	2000/07/01 14:14:15	1.16
+++ main/Makefile.in	2000/07/17 23:40:52
@@ -8,7 +8,7 @@
 	http_protocol.c http_request.c http_vhost.c util.c util_date.c \
 	util_script.c util_uri.c util_md5.c util_cfgtree.c util_ebcdic.c \
 	rfc1413.c http_connection.c iol_file.c iol_socket.c listen.c \
-        mpm_common.c util_charset.c util_debug.c util_xml.c
+        mpm_common.c util_charset.c util_debug.c util_xml.c util_filter.c
 
 include $(top_srcdir)/build/ltlib.mk
 
Index: main/http_core.c
===================================================================
RCS file: /home/cvs/apache-2.0/src/main/http_core.c,v
retrieving revision 1.88
diff -u -d -b -w -u -r1.88 http_core.c
--- main/http_core.c	2000/07/11 03:48:18	1.88
+++ main/http_core.c	2000/07/17 23:40:52
@@ -71,6 +71,8 @@
 #include "util_md5.h"
 #include "apr_fnmatch.h"
 #include "http_connection.h"
+#include "apr_buf.h"
+#include "util_filter.h"
 #include "util_ebcdic.h"
 #include "mpm.h"
 #ifdef HAVE_NETDB_H
@@ -86,6 +88,10 @@
 #include <strings.h>
 #endif
 
+/* Make sure we don't write less than 4096 bytes at any one time.
+ */
+#define MIN_SIZE_TO_WRITE  4096
+
 /* Allow Apache to use ap_mmap */
 #ifdef USE_MMAP_FILES
 #include "apr_mmap.h"
@@ -2872,6 +2878,51 @@
     return OK;
 }
 
+/* Default filter.  This filter should almost always be used.  It's only job
+ * is to send the headers if they haven't already been sent, and then send
+ * the actual data.  To send the data, we create an iovec out of the bucket
+ * brigade and then call the iol's writev function.  On platforms that don't
+ * have writev, we have the problem of creating a lot of potentially small
+ * packets that we are sending to the network.
+ *
+ * This can be solved later by making the buckets buffer everything into a
+ * single memory block that can be written using write (on those systems
+ * without writev only !)
+ */
+static int core_filter(request_rec *r, ap_filter_t *f, ap_bucket_brigade *b)
+{
+    ap_ssize_t bytes_sent;
+    ap_bucket *dptr;
+    int len = 0;
+
+    if (!r->headers_sent) {
+        ap_send_http_header_real(r);
+        r->headers_sent = 1;
+    }
+
+    /* At this point we need to discover if there was any data saved from
+     * the last call to core_filter.
+     */
+    b = ap_get_saved_data(r, f, &b);
+
+    /* It is very obvious that we need to make sure it makes sense to send data
+     * out at this point.
+     */
+    dptr = b->head; 
+    while (dptr) { 
+        len += ap_get_bucket_len(dptr);
+        dptr = dptr->next;
+    }
+    if (len < MIN_SIZE_TO_WRITE && b->tail->color != AP_BUCKET_eos) {
+        ap_save_data_to_filter(r, f, b);
+        return 0;
+    } 
+    else {
+        ap_bucket_brigade_to_iol(&bytes_sent, b, r->connection->client->iol);
+        return bytes_sent;
+    }
+}
+
 static const handler_rec core_handlers[] = {
 { "*/*", default_handler },
 { "default-handler", default_handler },
@@ -2894,6 +2945,11 @@
 static unsigned short core_port(const request_rec *r)
     { return DEFAULT_HTTP_PORT; }
 
+static void core_register_filter(request_rec *r)
+{
+    ap_hook_filter(core_filter, r, NULL, NULL, AP_HOOK_TRANSPORT_LAST);
+}
+
 static void register_hooks(void)
 {
     ap_hook_post_config(core_post_config,NULL,NULL,AP_HOOK_REALLY_FIRST);
@@ -2906,6 +2962,8 @@
     /* FIXME: I suspect we can eliminate the need for these - Ben */
     ap_hook_type_checker(do_nothing,NULL,NULL,AP_HOOK_REALLY_LAST);
     ap_hook_access_checker(do_nothing,NULL,NULL,AP_HOOK_REALLY_LAST);
+
+    ap_hook_insert_filter(core_register_filter, NULL, NULL, AP_HOOK_MIDDLE);
 }
 
 API_VAR_EXPORT module core_module = {
Index: main/http_protocol.c
===================================================================
RCS file: /home/cvs/apache-2.0/src/main/http_protocol.c,v
retrieving revision 1.96
diff -u -d -b -w -u -r1.96 http_protocol.c
--- main/http_protocol.c	2000/07/13 16:26:42	1.96
+++ main/http_protocol.c	2000/07/17 23:40:52
@@ -64,6 +64,8 @@
  */
 
 #define CORE_PRIVATE
+#include "apr_buf.h"
+#include "util_filter.h"
 #include "ap_config.h"
 #include "httpd.h"
 #include "http_config.h"
@@ -1720,7 +1722,7 @@
     }
 }
 
-API_EXPORT(void) ap_send_http_header(request_rec *r)
+API_EXPORT(void) ap_send_http_header_real(request_rec *r)
 {
     int i;
     const long int zero = 0L;
@@ -2443,15 +2445,23 @@
                              size_t length)
 {
     size_t total_bytes_sent = 0;
-    int n;
-    ap_ssize_t w;
-    char *addr;
+    ap_bucket_brigade *bb = NULL;
+    ap_bucket *b = NULL;
+    ap_filter_t *f;
     
+    /* if you are using the older API's, then Apache will initiate the 
+     * filtering for you.
+     */
+    f = ap_init_filter(r->pool);   
+    
     if (length == 0)
         return 0;
 
-
     length += offset;
+/* We can remove all of the MMAP_SEGMENT_SIZE stuff from Apache, because
+ * it is an optimization to be used for sending data.  Since we are using
+ * bucket-brigades we need to move this optimization down to the bucket
+ * brigade stuff, but that can wait for a day or two.
     while (!r->connection->aborted && offset < length) {
         if (length - offset > MMAP_SEGMENT_SIZE) {
             n = MMAP_SEGMENT_SIZE;
@@ -2467,76 +2477,132 @@
         total_bytes_sent += w;
         offset += w;
     }
+ */
 
-    SET_BYTES_SENT(r);
+    /* This is far too complex for a final API, but it is an okay
+     * start.  To finish this off, we will need a very clean API
+     * that does all of this for us.
+     */
+    bb = ap_bucket_brigade_create(r->pool);
+    b = ap_bucket_new(AP_BUCKET_mmap);
+    b->insert(b, mm, mm->size, &total_bytes_sent);
+    bb->head = bb->tail = b;
+    total_bytes_sent = ap_pass_brigade(r, f, bb);
+
     return total_bytes_sent;
 }
 #endif /* USE_MMAP_FILES */
 
 API_EXPORT(int) ap_rputc(int c, request_rec *r)
 {
+    ap_bucket_brigade *bb = NULL;
+    ap_bucket *b = NULL;
+    ap_ssize_t written;
+    ap_filter_t *f;
+
     if (r->connection->aborted)
         return EOF;
 
-    if (ap_bputc(c, r->connection->client) < 0) {
-        check_first_conn_error(r, "rputc", 0);
-        return EOF;
-    }
-    SET_BYTES_SENT(r);
+    /* if you are using the older API's, then Apache will initiate the 
+     * filtering for you.
+     */
+    f = ap_init_filter(r->pool);   
+
+    /* This is far too complex for a final API, but it is an okay
+     * start.  To finish this off, we will need a very clean API
+     * that does all of this for us.
+     */
+    bb = ap_bucket_brigade_create(r->pool);
+    b = ap_bucket_new(AP_BUCKET_rwmem);
+    b->insert(b, &c, 1, &written); 
+    bb->head = bb->tail = b;
+    ap_pass_brigade(r, f, bb);
+
     return c;
 }
 
 API_EXPORT(int) ap_rputs(const char *str, request_rec *r)
 {
-    int rcode;
+    ap_bucket_brigade *bb = NULL;
+    ap_bucket *b = NULL;
+    ap_ssize_t written;
+    ap_filter_t *f;
 
     if (r->connection->aborted)
         return EOF;
     
-    rcode = ap_bputs(str, r->connection->client);
-    if (rcode < 0) {
-        check_first_conn_error(r, "rputs", 0);
-        return EOF;
-    }
-    SET_BYTES_SENT(r);
-    return rcode;
+    /* if you are using the older API's, then Apache will initiate the 
+     * filtering for you.
+     */
+    f = ap_init_filter(r->pool);   
+
+    /* This is far too complex for a final API, but it is an okay
+     * start.  To finish this off, we will need a very clean API
+     * that does all of this for us.
+     */
+    bb = ap_bucket_brigade_create(r->pool);
+    b = ap_bucket_new(AP_BUCKET_rwmem);
+    b->insert(b, str, strlen(str), &written); 
+    bb->head = bb->tail = b;
+    ap_pass_brigade(r, f, bb);
+
+    return written;
 }
 
 API_EXPORT(int) ap_rwrite(const void *buf, int nbyte, request_rec *r)
 {
-    ap_ssize_t n;
-    ap_status_t rv;
+    ap_bucket_brigade *bb = NULL;
+    ap_bucket *b = NULL;
+    ap_ssize_t written;
+    ap_filter_t *f;
 
     if (r->connection->aborted)
         return EOF;
 
-    /* ### should loop to avoid partial writes */
-    rv = ap_bwrite(r->connection->client, buf, nbyte, &n);
-    if (rv != APR_SUCCESS) {
-        check_first_conn_error(r, "rwrite", rv);
-        return EOF;
-    }
-    SET_BYTES_SENT(r);
-    return n;
+    /* if you are using the older API's, then Apache will initiate the 
+     * filtering for you.
+     */
+    f = ap_init_filter(r->pool);   
+
+    /* This is far too complex for a final API, but it is an okay
+     * start.  To finish this off, we will need a very clean API
+     * that does all of this for us.
+     */
+    bb = ap_bucket_brigade_create(r->pool);
+    b = ap_bucket_new(AP_BUCKET_rwmem);
+    b->insert(b, buf, nbyte, &written); 
+    bb->head = bb->tail = b;
+    ap_pass_brigade(r, f, bb);
+    return written;
 }
 
 API_EXPORT(int) ap_vrprintf(request_rec *r, const char *fmt, va_list va)
 {
-    int n;
+    ap_bucket_brigade *bb = NULL;
+    ap_ssize_t written;
+    ap_filter_t *f;
 
     if (r->connection->aborted)
         return EOF;
 
-    n = ap_vbprintf(r->connection->client, fmt, va);
+    /* if you are using the older API's, then Apache will initiate the 
+     * filtering for you.
+     */
+    f = ap_init_filter(r->pool);   
 
-    if (n < 0) {
-        check_first_conn_error(r, "vrprintf", 0);
-        return EOF;
-    }
-    SET_BYTES_SENT(r);
-    return n;
+    /* This is far too complex for a final API, but it is an okay
+     * start.  To finish this off, we will need a very clean API
+     * that does all of this for us.
+     */
+    bb = ap_bucket_brigade_create(r->pool);
+    written = ap_brigade_vprintf(bb, fmt, va);
+    ap_pass_brigade(r, f, bb);
+    return written;
 }
 
+/* TODO:  Make ap pa_bucket_vprintf that printfs directly into a
+ * bucket.
+ */
 API_EXPORT_NONSTD(int) ap_rprintf(request_rec *r, const char *fmt, ...)
 {
     va_list va;
@@ -2546,46 +2612,58 @@
         return EOF;
 
     va_start(va, fmt);
-    n = ap_vbprintf(r->connection->client, fmt, va);
+    n = ap_vrprintf(r, fmt, va);
     va_end(va);
 
-    if (n < 0) {
-        check_first_conn_error(r, "rprintf", 0);
-        return EOF;
-    }
-    SET_BYTES_SENT(r);
     return n;
 }
 
 API_EXPORT_NONSTD(int) ap_rvputs(request_rec *r, ...)
 {
+    ap_bucket_brigade *bb = NULL;
+    ap_ssize_t written;
+    ap_filter_t *f;
     va_list va;
-    int n;
 
     if (r->connection->aborted)
         return EOF;
 
+    /* if you are using the older API's, then Apache will initiate the 
+     * filtering for you.
+     */
+    f = ap_init_filter(r->pool);   
+
+    /* This is far too complex for a final API, but it is an okay
+     * start.  To finish this off, we will need a very clean API
+     * that does all of this for us.
+     */
+    bb = ap_bucket_brigade_create(r->pool);
     va_start(va, r);
-    n = ap_vbputstrs(r->connection->client, va);
+    written = ap_brigade_vputstrs(bb, va);
     va_end(va);
-
-    if (n < 0) {
-        check_first_conn_error(r, "rvputs", 0);
-        return EOF;
-    }
-
-    SET_BYTES_SENT(r);
-    return n;
+    ap_pass_brigade(r, f, bb);
+    return written;
 }
 
 API_EXPORT(int) ap_rflush(request_rec *r)
 {
-    ap_status_t rv;
+    ap_bucket_brigade *bb;
+    ap_bucket *b;
+    ap_filter_t *f;
 
-    if ((rv = ap_bflush(r->connection->client)) != APR_SUCCESS) {
-        check_first_conn_error(r, "rflush", rv);
-        return EOF;
-    }
+    /* if you are using the older API's, then Apache will initiate the 
+     * filtering for you.
+     */
+    f = ap_init_filter(r->pool);   
+
+    /* This is far too complex for a final API, but it is an okay
+     * start.  To finish this off, we will need a very clean API
+     * that does all of this for us.
+     */
+    bb = ap_bucket_brigade_create(r->pool);
+    b = ap_bucket_new(AP_BUCKET_eos);
+    bb->head = bb->tail = b;
+    ap_pass_brigade(r, f, bb);
     return 0;
 }
 
Index: main/http_request.c
===================================================================
RCS file: /home/cvs/apache-2.0/src/main/http_request.c,v
retrieving revision 1.35
diff -u -d -b -w -u -r1.35 http_request.c
--- main/http_request.c	2000/06/24 17:33:57	1.35
+++ main/http_request.c	2000/07/17 23:40:52
@@ -1263,6 +1263,12 @@
         return;
     }
 
+    /* We need to flush the data out at this point.  We probably only want to
+     * do this on the main request, but this is fine for an initial patch.
+     * Once we look into this more, we won't flush sub-requests.
+     */
+    ap_rflush(r);
+
     /* Take care of little things that need to happen when we're done */
     ap_finalize_request_protocol(r);
 }
Index: modules/mpm/config.m4
===================================================================
RCS file: /home/cvs/apache-2.0/src/modules/mpm/config.m4,v
retrieving revision 1.23
diff -u -d -b -w -u -r1.23 config.m4
--- modules/mpm/config.m4	2000/07/11 19:00:16	1.23
+++ modules/mpm/config.m4	2000/07/17 23:40:58
@@ -3,7 +3,6 @@
 [  --with-mpm=MPM          Choose the process model for Apache to use.
                           MPM={dexter,mpmt_beos,mpmt_pthread,prefork,spmt_os2}],[
   APACHE_MPM=$withval
-  mpm_explicit="yes"
 ],[
   APACHE_MPM=mpmt_pthread
   PLAT=`$ac_config_guess`
@@ -14,7 +13,6 @@
     *os2_emx*)
       APACHE_MPM=spmt_os2;;
   esac 
-  mpm_explicit="no"
 ])
 AC_MSG_RESULT($APACHE_MPM)
 
@@ -41,10 +39,11 @@
 MPM_DIR=modules/mpm/$MPM_NAME
 MPM_LIB=$MPM_DIR/lib${MPM_NAME}.la
 
-if test "$mpm_explicit" = "no"; then
   if test "$MPM_NAME" = "prefork" ; then
     MPM_NAME="prefork"
     MPM_FAKE_NAME=prefork.c
+    ln -s mpmt.c modules/mpm/mpmt/prefork.c
+    
     EXTRA_CFLAGS="$EXTRA_CFLAGS -DPREFORK"
 
     ac_cv_enable_threads="no"
@@ -78,7 +77,6 @@
     MPM_DIR=modules/mpm/$MPM_NAME
     MPM_LIB=$MPM_DIR/lib${MPM_NAME}.la
   fi
-fi
 
 APACHE_SUBST(MPM_NAME)
 APACHE_SUBST(MPM_FAKE_NAME)
