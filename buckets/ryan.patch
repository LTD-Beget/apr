? build.log
? build.err
? src/build.log
? src/build.err
? src/lib/apr/buckets/Makefile.in
? src/lib/apr/include/apr_buf.h
Index: src/ap/Makefile.in
===================================================================
RCS file: /home/cvs/apache-2.0/src/ap/Makefile.in,v
retrieving revision 1.4
diff -u -d -b -w -u -r1.4 Makefile.in
--- src/ap/Makefile.in	2000/06/12 20:41:13	1.4
+++ src/ap/Makefile.in	2000/08/05 05:01:14
@@ -1,5 +1,5 @@
 
 LTLIBRARY_NAME    = libap.la
-LTLIBRARY_SOURCES = ap_cache.c ap_base64.c ap_sha1.c ap_buf.c ap_hooks.c
+LTLIBRARY_SOURCES = ap_cache.c ap_base64.c ap_sha1.c ap_hooks.c 
 
 include $(top_srcdir)/build/ltlib.mk
Index: src/include/ap_iol.h
===================================================================
RCS file: /home/cvs/apache-2.0/src/include/ap_iol.h,v
retrieving revision 1.23
diff -u -d -b -w -u -r1.23 ap_iol.h
--- src/include/ap_iol.h	2000/08/02 17:51:36	1.23
+++ src/include/ap_iol.h	2000/08/05 05:01:14
@@ -58,7 +58,9 @@
 #define AP_IOL_H
 
 #include "apr_general.h" /* For ap_s?size_t */
-#include "apr_errno.h" /* For apr_status_t and the APR_errnos */
+#include "apr_network_io.h" /* For ap_hdtr_t */
+#include "apr_errno.h" /* For ap_status_t and the APR_errnos */
+#include "ap_config.h" /* For ap_status_t and the APR_errnos */
 
 typedef struct ap_iol ap_iol;
 typedef struct ap_iol_methods ap_iol_methods;
Index: src/include/http_protocol.h
===================================================================
RCS file: /home/cvs/apache-2.0/src/include/http_protocol.h,v
retrieving revision 1.20
diff -u -d -b -w -u -r1.20 http_protocol.h
--- src/include/http_protocol.h	2000/08/02 05:25:28	1.20
+++ src/include/http_protocol.h	2000/08/05 05:01:14
@@ -88,8 +88,19 @@
  */
 API_EXPORT(void) ap_basic_http_header(request_rec *r);
 
-/* Send the Status-Line and header fields for HTTP response */
-
+/* Send the Status-Line and header fields for HTTP response.  Two functions
+ * are needed here because we are doing two very different things.  1)  We
+ * setup the response based on the header values.  For example, se setup
+ * chunking based on the values in the headers.  This is done in
+ * ap_send_http_header.  A slightly incorrect name, but it is the name from
+ * 1.3, so this means modules don't need to change as much.  2)  Actually
+ * send the headers over the wire.  Currently this is done in
+ * ap_send_http_header_real.  This should most likely be changed to just
+ * create a bucket that contains the headers.  In this way, the headers are
+ * treated just like regular data, and we avoid BUFF all together.  That however
+ * is an enhancement that can be made after the core filtering is in place.
+ */
+API_EXPORT(void) ap_send_http_header_real(request_rec *l);
 API_EXPORT(void) ap_send_http_header(request_rec *l);
 
 /* Send the response to special method requests */
Index: src/include/httpd.h
===================================================================
RCS file: /home/cvs/apache-2.0/src/include/httpd.h,v
retrieving revision 1.69
diff -u -d -b -w -u -r1.69 httpd.h
--- src/include/httpd.h	2000/08/04 17:40:02	1.69
+++ src/include/httpd.h	2000/08/05 05:01:15
@@ -589,6 +589,10 @@
 				 * pointer back to the main request.
 				 */
 
+    int headers_sent;           /* Have we sent the headers for this request
+                                 * yet.
+                                 */
+
     /* Info about the request itself... we begin with stuff that only
      * protocol.c should ever touch...
      */
@@ -725,7 +729,7 @@
     struct ap_rr_xlate *rrx;
 #endif /*APACHE_XLATE*/
 
-    struct apr_filter_t *filters;
+    struct ap_filter_t *filters;
 
 /* Things placed at the end of the record to avoid breaking binary
  * compatibility.  It would be nice to remember to reorder the entire
Index: src/include/util_filter.h
===================================================================
RCS file: /home/cvs/apache-2.0/src/include/util_filter.h,v
retrieving revision 1.3
diff -u -d -b -w -u -r1.3 util_filter.h
--- src/include/util_filter.h	2000/08/05 04:38:57	1.3
+++ src/include/util_filter.h	2000/08/05 05:01:15
@@ -65,6 +65,7 @@
 
 #include "httpd.h"
 #include "apr.h"
+#include "apr_buf.h"
 
 /*
  * FILTER CHAIN
@@ -114,7 +115,7 @@
  * next/prev to insert/remove/replace elements in the bucket list, but
  * the types and values of the individual buckets should not be altered.
  */
-typedef apr_status_t (*ap_filter_func)();
+typedef apr_status_t (*ap_filter_func)(request_rec *r, ap_filter_t *f, ap_bucket_brigade *b);
 
 /*
  * ap_filter_type:
@@ -168,6 +169,19 @@
     ap_filter_t *next;
 };
 
+/* This function just passes the current bucket brigade down to the next
+ * filter on the filter stack.  When a filter actually writes to the network
+ * (usually either core or SSL), that filter should return the number of bytes
+ * actually written and it will get propogated back up to the handler.  If
+ * nobody writes the data to the network, then this function will most likely
+ * seg fault.  I haven't come up with a good way to detect that case yet, and
+ * it should never happen.  Regardless, it's an unrecoverable error for the
+ * current request.  I would just rather it didn't take out the whole child
+ * process.  
+ */
+API_EXPORT(int) ap_pass_brigade(request_rec *r, ap_filter_t *filter,
+                                 ap_bucket_brigade *bucket);
+
 /*
  * ap_register_filter():
  *
@@ -192,9 +206,28 @@
  * calls to ap_add_filter). If the current filter chain contains filters
  * from another request, then this filter will be added before those other
  * filters.
+ * 
+ * To re-iterate that last comment.  This function is building a FIFO
+ * list of filters.  Take note of that when adding your filter to the chain.
  */
 API_EXPORT(void) ap_add_filter(const char *name, void *ctx, request_rec *r);
 
+/* The next two filters are for abstraction purposes only.  They could be
+ * done away with, but that would require that we break modules if we ever
+ * want to change our filter registration method.  The basic idea, is that
+ * all filters have a place to store data, the ctx pointer.  These functions
+ * fill out that pointer with a bucket brigade, and retrieve that data on
+ * the next call.  The nice thing about these functions, is that they
+ * automatically concatenate the bucket brigades together for you.  This means
+ * that if you have already stored a brigade in the filters ctx pointer, then
+ * when you add more it will be tacked onto the end of that brigade.  When
+ * you retrieve data, if you pass in a bucket brigade to the get function,
+ * it will append the current brigade onto the one that you are retrieving.
+ */ 
+API_EXPORT(ap_bucket_brigade *) ap_get_saved_data(request_rec *r, 
+                                   ap_filter_t *f, ap_bucket_brigade **b);
+API_EXPORT(void) ap_save_data_to_filter(request_rec *r, ap_filter_t *f,
+                                   ap_bucket_brigade **b);    
 
 /*
  * Things to do later:
@@ -206,12 +239,6 @@
  *      bucket_brigade, but I am trying to keep this patch neutral.  (If this
  *      comment breaks that, well sorry, but the information must be there
  *      somewhere.  :-)
- *
- * Add a function like ap_pass_data.  This function will basically just
- * call the next filter in the chain, until the current filter is NULL.  If the
- * current filter is NULL, that means that nobody wrote to the network, and
- * we have a HUGE bug, so we need to return an error and log it to the 
- * log file.
  */
 #ifdef __cplusplus
 }
Index: src/lib/apr/configure.in
===================================================================
RCS file: /home/cvs/apache-2.0/src/lib/apr/configure.in,v
retrieving revision 1.143
diff -u -d -b -w -u -r1.143 configure.in
--- src/lib/apr/configure.in	2000/08/02 05:51:39	1.143
+++ src/lib/apr/configure.in	2000/08/05 05:01:15
@@ -688,8 +688,8 @@
 AC_SUBST(EXEEXT)
 
 echo "Construct Makefiles and header files."
-MAKEFILE1="Makefile lib/Makefile strings/Makefile passwd/Makefile tables/Makefile"
-SUBDIRS="lib strings passwd tables "
+MAKEFILE1="Makefile lib/Makefile strings/Makefile passwd/Makefile tables/Makefile buckets/Makefile"
+SUBDIRS="lib strings passwd tables buckets "
 for dir in $MODULES
 do
     test -d $dir || $MKDIR -p $dir
Index: src/main/http_core.c
===================================================================
RCS file: /home/cvs/apache-2.0/src/main/http_core.c,v
retrieving revision 1.94
diff -u -d -b -w -u -r1.94 http_core.c
--- src/main/http_core.c	2000/08/02 05:26:47	1.94
+++ src/main/http_core.c	2000/08/05 05:01:22
@@ -72,6 +72,8 @@
 #include "util_md5.h"
 #include "apr_fnmatch.h"
 #include "http_connection.h"
+#include "apr_buf.h"
+#include "util_filter.h"
 #include "util_ebcdic.h"
 #include "mpm.h"
 #ifdef HAVE_NETDB_H
@@ -87,6 +89,10 @@
 #include <strings.h>
 #endif
 
+/* Make sure we don't write less than 4096 bytes at any one time.
+ */
+#define MIN_SIZE_TO_WRITE  4096
+
 /* Allow Apache to use ap_mmap */
 #ifdef USE_MMAP_FILES
 #include "apr_mmap.h"
@@ -2880,6 +2886,52 @@
     return OK;
 }
 
+/* Default filter.  This filter should almost always be used.  It's only job
+ * is to send the headers if they haven't already been sent, and then send
+ * the actual data.  To send the data, we create an iovec out of the bucket
+ * brigade and then call the iol's writev function.  On platforms that don't
+ * have writev, we have the problem of creating a lot of potentially small
+ * packets that we are sending to the network.
+ *
+ * This can be solved later by making the buckets buffer everything into a
+ * single memory block that can be written using write (on those systems
+ * without writev only !)
+ */
+static int core_filter(request_rec *r, ap_filter_t *f, ap_bucket_brigade *b)
+{
+    ap_bucket *dptr = b->head;
+    apr_ssize_t bytes_sent;
+    int len = 0;
+
+    if (!r->headers_sent) {
+        ap_send_http_header_real(r);
+        ap_bflush(r->connection->client);
+        r->headers_sent = 1;
+    }
+
+    /* At this point we need to discover if there was any data saved from
+     * the last call to core_filter.
+     */
+    b = ap_get_saved_data(r, f, &b);
+
+    /* It is very obvious that we need to make sure it makes sense to send data
+     * out at this point.
+     */
+    dptr = b->head; 
+    while (dptr) { 
+        len += ap_get_bucket_len(dptr);
+        dptr = dptr->next;
+    }
+    if (len < MIN_SIZE_TO_WRITE && b->tail->color != AP_BUCKET_eos) {
+        ap_save_data_to_filter(r, f, &b);
+        return 0;
+    } 
+    else {
+        ap_brigade_to_iol(&bytes_sent, b, r->connection->client->iol);
+        return bytes_sent;
+    }
+}
+
 static const handler_rec core_handlers[] = {
 { "*/*", default_handler },
 { "default-handler", default_handler },
@@ -2902,6 +2954,11 @@
 static unsigned short core_port(const request_rec *r)
     { return DEFAULT_HTTP_PORT; }
 
+static void core_register_filter(request_rec *r)
+{
+    ap_add_filter("CORE", NULL, r);
+}
+
 static void register_hooks(void)
 {
     ap_hook_post_config(core_post_config,NULL,NULL,AP_HOOK_REALLY_FIRST);
@@ -2914,6 +2971,14 @@
     /* FIXME: I suspect we can eliminate the need for these - Ben */
     ap_hook_type_checker(do_nothing,NULL,NULL,AP_HOOK_REALLY_LAST);
     ap_hook_access_checker(do_nothing,NULL,NULL,AP_HOOK_REALLY_LAST);
+
+    /* This is kind of odd, and it would be cool to clean it up a bit.
+     * The first function just registers the core's register_filter hook.
+     * The other associates a global name with the filter defined
+     * by the core module.
+     */
+    ap_hook_insert_filter(core_register_filter, NULL, NULL, AP_HOOK_MIDDLE);
+    ap_register_filter("CORE", core_filter, AP_FTYPE_CONNECTION);
 }
 
 API_VAR_EXPORT module core_module = {
Index: src/main/http_protocol.c
===================================================================
RCS file: /home/cvs/apache-2.0/src/main/http_protocol.c,v
retrieving revision 1.100
diff -u -d -b -w -u -r1.100 http_protocol.c
--- src/main/http_protocol.c	2000/08/02 05:26:48	1.100
+++ src/main/http_protocol.c	2000/08/05 05:01:22
@@ -64,6 +64,8 @@
  */
 
 #define CORE_PRIVATE
+#include "apr_buf.h"
+#include "util_filter.h"
 #include "ap_config.h"
 #include "apr_strings.h"
 #include "httpd.h"
@@ -1824,8 +1826,12 @@
         apr_rfc822_date(date, r->request_time);
         apr_table_addn(r->headers_out, "Expires", date);
     }
+}
 
-    /* Send the entire apr_table_t of header fields, terminated by an empty line. */
+API_EXPORT(void) ap_send_http_header_real(request_rec *r)
+{
+    const long int zero = 0L;
+    /* Send the entire ap_table_t of header fields, terminated by an empty line. */
 
     apr_table_do((int (*) (void *, const char *, const char *)) ap_send_header_field,
              (void *) r, r->headers_out, NULL);
@@ -2468,101 +2474,84 @@
 API_EXPORT(size_t) ap_send_mmap(apr_mmap_t *mm, request_rec *r, size_t offset,
                              size_t length)
 {
-    size_t total_bytes_sent = 0;
-    int n;
-    apr_ssize_t w;
-    char *addr;
-    
-    if (length == 0)
-        return 0;
-
-
-    length += offset;
-    while (!r->connection->aborted && offset < length) {
-        if (length - offset > MMAP_SEGMENT_SIZE) {
-            n = MMAP_SEGMENT_SIZE;
-        }
-        else {
-            n = length - offset;
-        }
+    size_t bytes_sent = 0;
+    ap_bucket_brigade *bb = NULL;
 
-        apr_mmap_offset((void**)&addr, mm, offset);
-        w = ap_rwrite(addr, n, r);
-        if (w < 0)
-            break;
-        total_bytes_sent += w;
-        offset += w;
-    }
+    /* WE probably need to do something to make sure we are respecting the
+     * offset and length.  I think I know how to do this, but I will wait
+     * until after the commit to actually write the code.
+     */
+    bb = ap_brigade_create(r->pool);
+    ap_brigade_append_buckets(bb, 
+                            ap_bucket_mmap_create(mm, mm->size, &bytes_sent));
+    bytes_sent = ap_pass_brigade(r, NULL, bb);
 
-    SET_BYTES_SENT(r);
-    return total_bytes_sent;
+    return bytes_sent;
 }
 #endif /* USE_MMAP_FILES */
 
 API_EXPORT(int) ap_rputc(int c, request_rec *r)
 {
+    ap_bucket_brigade *bb = NULL;
+    apr_ssize_t written;
+
     if (r->connection->aborted)
         return EOF;
 
-    if (ap_bputc(c, r->connection->client) < 0) {
-        check_first_conn_error(r, "rputc", 0);
-        return EOF;
-    }
-    SET_BYTES_SENT(r);
+    bb = ap_brigade_create(r->pool);
+    ap_brigade_append_buckets(bb, ap_bucket_rwmem_create(&c, 1, &written)); 
+    ap_pass_brigade(r, NULL, bb);
+
     return c;
 }
 
 API_EXPORT(int) ap_rputs(const char *str, request_rec *r)
 {
-    int rcode;
+    ap_bucket_brigade *bb = NULL;
+    apr_ssize_t written;
 
     if (r->connection->aborted)
         return EOF;
     
-    rcode = ap_bputs(str, r->connection->client);
-    if (rcode < 0) {
-        check_first_conn_error(r, "rputs", 0);
-        return EOF;
-    }
-    SET_BYTES_SENT(r);
-    return rcode;
+    bb = ap_brigade_create(r->pool);
+    ap_brigade_append_buckets(bb, 
+                           ap_bucket_rwmem_create(str, strlen(str), &written)); 
+    ap_pass_brigade(r, NULL, bb);
+
+    return written;
 }
 
 API_EXPORT(int) ap_rwrite(const void *buf, int nbyte, request_rec *r)
 {
-    apr_ssize_t n;
-    apr_status_t rv;
+    ap_bucket_brigade *bb = NULL;
+    apr_ssize_t written;
 
     if (r->connection->aborted)
         return EOF;
 
-    /* ### should loop to avoid partial writes */
-    rv = ap_bwrite(r->connection->client, buf, nbyte, &n);
-    if (rv != APR_SUCCESS) {
-        check_first_conn_error(r, "rwrite", rv);
-        return EOF;
-    }
-    SET_BYTES_SENT(r);
-    return n;
+    bb = ap_brigade_create(r->pool);
+    ap_brigade_append_buckets(bb, ap_bucket_rwmem_create(buf, nbyte, &written)); 
+    ap_pass_brigade(r, NULL, bb);
+    return written;
 }
 
 API_EXPORT(int) ap_vrprintf(request_rec *r, const char *fmt, va_list va)
 {
-    int n;
+    ap_bucket_brigade *bb = NULL;
+    apr_ssize_t written;
 
     if (r->connection->aborted)
         return EOF;
 
-    n = ap_vbprintf(r->connection->client, fmt, va);
-
-    if (n < 0) {
-        check_first_conn_error(r, "vrprintf", 0);
-        return EOF;
-    }
-    SET_BYTES_SENT(r);
-    return n;
+    bb = ap_brigade_create(r->pool);
+    written = ap_brigade_vprintf(bb, fmt, va);
+    ap_pass_brigade(r, NULL, bb);
+    return written;
 }
 
+/* TODO:  Make ap pa_bucket_vprintf that printfs directly into a
+ * bucket.
+ */
 API_EXPORT_NONSTD(int) ap_rprintf(request_rec *r, const char *fmt, ...)
 {
     va_list va;
@@ -2572,46 +2561,35 @@
         return EOF;
 
     va_start(va, fmt);
-    n = ap_vbprintf(r->connection->client, fmt, va);
+    n = ap_vrprintf(r, fmt, va);
     va_end(va);
 
-    if (n < 0) {
-        check_first_conn_error(r, "rprintf", 0);
-        return EOF;
-    }
-    SET_BYTES_SENT(r);
     return n;
 }
 
 API_EXPORT_NONSTD(int) ap_rvputs(request_rec *r, ...)
 {
+    ap_bucket_brigade *bb = NULL;
+    apr_ssize_t written;
     va_list va;
-    int n;
 
     if (r->connection->aborted)
         return EOF;
-
+    bb = ap_brigade_create(r->pool);
     va_start(va, r);
-    n = ap_vbputstrs(r->connection->client, va);
+    written = ap_brigade_vputstrs(bb, va);
     va_end(va);
-
-    if (n < 0) {
-        check_first_conn_error(r, "rvputs", 0);
-        return EOF;
-    }
-
-    SET_BYTES_SENT(r);
-    return n;
+    ap_pass_brigade(r, NULL, bb);
+    return written;
 }
 
 API_EXPORT(int) ap_rflush(request_rec *r)
 {
-    apr_status_t rv;
+    ap_bucket_brigade *bb;
 
-    if ((rv = ap_bflush(r->connection->client)) != APR_SUCCESS) {
-        check_first_conn_error(r, "rflush", rv);
-        return EOF;
-    }
+    bb = ap_brigade_create(r->pool);
+    ap_brigade_append_buckets(bb, ap_bucket_eos_create());
+    ap_pass_brigade(r, NULL, bb);
     return 0;
 }
 
Index: src/main/http_request.c
===================================================================
RCS file: /home/cvs/apache-2.0/src/main/http_request.c,v
retrieving revision 1.38
diff -u -d -b -w -u -r1.38 http_request.c
--- src/main/http_request.c	2000/08/02 05:26:48	1.38
+++ src/main/http_request.c	2000/08/05 05:01:22
@@ -1276,6 +1276,12 @@
         return;
     }
 
+    /* We need to flush the data out at this point.  We probably only want to
+     * do this on the main request, but this is fine for an initial patch.
+     * Once we look into this more, we won't flush sub-requests.
+     */
+    ap_rflush(r);
+
     /* Take care of little things that need to happen when we're done */
     ap_finalize_request_protocol(r);
 }
Index: src/main/util_filter.c
===================================================================
RCS file: /home/cvs/apache-2.0/src/main/util_filter.c,v
retrieving revision 1.3
diff -u -d -b -w -u -r1.3 util_filter.c
--- src/main/util_filter.c	2000/08/05 04:38:58	1.3
+++ src/main/util_filter.c	2000/08/05 05:01:22
@@ -52,6 +52,7 @@
  * <http://www.apache.org/>.
  */
 
+#include "httpd.h"
 #include "util_filter.h"
 
 /*
@@ -73,7 +74,7 @@
 } ap_filter_rec_t;
 
 /* ### make this visible for direct manipulation?
-   ### use a hash table
+ * ### use a hash table
 */
 static ap_filter_rec_t *registered_filters = NULL;
 
@@ -144,3 +145,63 @@
     }
 }
 
+/* Pass the buckets to the next filter in the filter stack.  If the
+ * current filter is a handler, we should get NULL passed in instead of
+ * the current filter.  At that point, we can just call the first filter in
+ * the stack, or r->filters.
+ */
+API_EXPORT(int) ap_pass_brigade(request_rec *r, ap_filter_t *filter,
+                                 ap_bucket_brigade *bb)
+{
+    if (filter) {
+        return (*filter->next->filter_func)(r, filter->next, bb);
+    }
+    else {
+        return (*r->filters->filter_func)(r, r->filters, bb);
+    }
+}
+
+API_EXPORT(ap_bucket_brigade *) ap_get_saved_data(request_rec *r,
+                                   ap_filter_t *f, ap_bucket_brigade **b)
+{
+    ap_bucket_brigade *bb = (ap_bucket_brigade *)f->ctx;
+
+    /* If we have never stored any data in the filter, then we had better
+     * create an empty bucket brigade so that we can concat.
+     */
+    if (!bb) {
+        bb = ap_brigade_create(r->pool);
+    }
+
+    /* join the two brigades together.  *b is now empty so we can 
+     * safely destroy it. 
+     */
+    ap_brigade_catenate(bb, *b);
+    ap_brigade_destroy(*b);
+    /* clear out the filter's context pointer.  If we don't do this, then
+     * when we save more data to the filter, we will be appended to what is
+     * currently there.  This will mean repeating data.... BAD!  :-)
+     */
+    f->ctx = NULL;
+    
+    return bb;
+}
+
+API_EXPORT(void) ap_save_data_to_filter(request_rec *r, ap_filter_t *f,
+                                   ap_bucket_brigade **b)
+{
+    ap_bucket_brigade *bb = (ap_bucket_brigade *)f->ctx;
+
+    /* If have never stored any data in the filter, then we had better
+     * create an empty bucket brigade so that we can concat.
+     */
+    if (!bb) {
+        bb = ap_brigade_create(r->pool);
+    }
+
+    /* Apend b to bb.  This means b is now empty, and we can destory it safely. 
+     */
+    ap_brigade_catenate(bb, *b);
+    ap_brigade_destroy(*b);
+    f->ctx = bb;
+}
Index: src/os/unix/os.h
===================================================================
RCS file: /home/cvs/apache-2.0/src/os/unix/os.h,v
retrieving revision 1.10
diff -u -d -b -w -u -r1.10 os.h
--- src/os/unix/os.h	2000/05/15 23:02:57	1.10
+++ src/os/unix/os.h	2000/08/05 05:01:25
@@ -59,8 +59,6 @@
 #ifndef APACHE_OS_H
 #define APACHE_OS_H
 
-#include "ap_config.h"
-
 #ifndef PLATFORM
 #define PLATFORM "Unix"
 #endif
