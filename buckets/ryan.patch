? include/util_filter.h
? lib/apr/buckets/Makefile.in
? lib/apr/include/apr_buf.h
? main/util_filter.c
Index: ap/Makefile.in
===================================================================
RCS file: /home/cvs/apache-2.0/src/ap/Makefile.in,v
retrieving revision 1.4
diff -u -d -b -w -u -r1.4 Makefile.in
--- ap/Makefile.in	2000/06/12 20:41:13	1.4
+++ ap/Makefile.in	2000/07/20 21:16:23
@@ -1,5 +1,5 @@
 
 LTLIBRARY_NAME    = libap.la
-LTLIBRARY_SOURCES = ap_cache.c ap_base64.c ap_sha1.c ap_buf.c ap_hooks.c
+LTLIBRARY_SOURCES = ap_cache.c ap_base64.c ap_sha1.c ap_hooks.c 
 
 include $(top_srcdir)/build/ltlib.mk
Index: include/ap_iol.h
===================================================================
RCS file: /home/cvs/apache-2.0/src/include/ap_iol.h,v
retrieving revision 1.19
diff -u -d -b -w -u -r1.19 ap_iol.h
--- include/ap_iol.h	2000/05/29 04:22:02	1.19
+++ include/ap_iol.h	2000/07/20 21:16:23
@@ -58,6 +58,7 @@
 #define AP_IOL_H
 
 #include "apr_general.h" /* For ap_s?size_t */
+#include "apr_network_io.h" /* For ap_hdtr_t */
 #include "apr_errno.h" /* For ap_status_t and the APR_errnos */
 
 typedef struct ap_iol ap_iol;
Index: include/http_protocol.h
===================================================================
RCS file: /home/cvs/apache-2.0/src/include/http_protocol.h,v
retrieving revision 1.19
diff -u -d -b -w -u -r1.19 http_protocol.h
--- include/http_protocol.h	2000/07/11 03:48:17	1.19
+++ include/http_protocol.h	2000/07/20 21:16:23
@@ -89,7 +89,7 @@
 API_EXPORT(void) ap_basic_http_header(request_rec *r);
 
 /* Send the Status-Line and header fields for HTTP response */
-
+API_EXPORT(void) ap_send_http_header_real(request_rec *l);
 API_EXPORT(void) ap_send_http_header(request_rec *l);
 
 /* Send the response to special method requests */
Index: include/httpd.h
===================================================================
RCS file: /home/cvs/apache-2.0/src/include/httpd.h,v
retrieving revision 1.64
diff -u -d -b -w -u -r1.64 httpd.h
--- include/httpd.h	2000/06/30 21:18:13	1.64
+++ include/httpd.h	2000/07/20 21:16:23
@@ -596,6 +596,11 @@
 				 * pointer back to the main request.
 				 */
 
+    ap_array_header_t *filters; /* The array of filters to call */
+    int headers_sent;           /* Have we sent the headers for this request
+                                 * yet.
+                                 */
+
     /* Info about the request itself... we begin with stuff that only
      * protocol.c should ever touch...
      */
Index: lib/apr/configure.in
===================================================================
RCS file: /home/cvs/apache-2.0/src/lib/apr/configure.in,v
retrieving revision 1.136
diff -u -d -b -w -u -r1.136 configure.in
--- lib/apr/configure.in	2000/07/15 15:39:05	1.136
+++ lib/apr/configure.in	2000/07/20 21:16:24
@@ -682,8 +682,8 @@
 AC_SUBST(EXEEXT)
 
 echo "Construct Makefiles and header files."
-MAKEFILE1="Makefile lib/Makefile "
-SUBDIRS="lib "
+MAKEFILE1="Makefile lib/Makefile buckets/Makefile"
+SUBDIRS="lib buckets"
 for dir in $MODULES
 do
     test -d $dir || $MKDIR -p $dir
Index: main/Makefile.in
===================================================================
RCS file: /home/cvs/apache-2.0/src/main/Makefile.in,v
retrieving revision 1.16
diff -u -d -b -w -u -r1.16 Makefile.in
--- main/Makefile.in	2000/07/01 14:14:15	1.16
+++ main/Makefile.in	2000/07/20 21:16:29
@@ -8,7 +8,7 @@
 	http_protocol.c http_request.c http_vhost.c util.c util_date.c \
 	util_script.c util_uri.c util_md5.c util_cfgtree.c util_ebcdic.c \
 	rfc1413.c http_connection.c iol_file.c iol_socket.c listen.c \
-        mpm_common.c util_charset.c util_debug.c util_xml.c
+        mpm_common.c util_charset.c util_debug.c util_xml.c util_filter.c
 
 include $(top_srcdir)/build/ltlib.mk
 
Index: main/http_core.c
===================================================================
RCS file: /home/cvs/apache-2.0/src/main/http_core.c,v
retrieving revision 1.88
diff -u -d -b -w -u -r1.88 http_core.c
--- main/http_core.c	2000/07/11 03:48:18	1.88
+++ main/http_core.c	2000/07/20 21:16:29
@@ -71,6 +71,8 @@
 #include "util_md5.h"
 #include "apr_fnmatch.h"
 #include "http_connection.h"
+#include "apr_buf.h"
+#include "util_filter.h"
 #include "util_ebcdic.h"
 #include "mpm.h"
 #ifdef HAVE_NETDB_H
@@ -86,6 +88,10 @@
 #include <strings.h>
 #endif
 
+/* Make sure we don't write less than 4096 bytes at any one time.
+ */
+#define MIN_SIZE_TO_WRITE  4096
+
 /* Allow Apache to use ap_mmap */
 #ifdef USE_MMAP_FILES
 #include "apr_mmap.h"
@@ -2872,6 +2878,76 @@
     return OK;
 }
 
+/* This is an incredibly stupid chunking filter.  This will need to be somewhat
+ * smart about when it actually sends the data, but this implements some sort
+ * of chunking for right now.
+ */
+static int chunk_filter(request_rec *r, ap_filter_t *f, ap_bucket_brigade *b)
+{
+    ap_bucket *dptr = b->head;
+    ap_bucket_brigade *c = ap_bucket_brigade_create(r->pool);
+    int len = 0;
+
+    while (dptr) { 
+        len += ap_get_bucket_len(dptr);
+        dptr = dptr->next;
+    }
+     
+    ap_brigade_printf(c, "%x\r\n", len);
+    ap_bucket_brigade_catenate(c, b);
+    dptr = ap_bucket_rwmem_create();
+    dptr->insert(dptr, "\r\n", 2, &len);
+    ap_bucket_brigade_append_buckets(c, dptr);
+
+    return ap_pass_brigade(r, f, c);
+}
+
+/* Default filter.  This filter should almost always be used.  It's only job
+ * is to send the headers if they haven't already been sent, and then send
+ * the actual data.  To send the data, we create an iovec out of the bucket
+ * brigade and then call the iol's writev function.  On platforms that don't
+ * have writev, we have the problem of creating a lot of potentially small
+ * packets that we are sending to the network.
+ *
+ * This can be solved later by making the buckets buffer everything into a
+ * single memory block that can be written using write (on those systems
+ * without writev only !)
+ */
+static int core_filter(request_rec *r, ap_filter_t *f, ap_bucket_brigade *b)
+{
+    ap_bucket *dptr = b->head;
+    ap_ssize_t bytes_sent;
+    int len = 0;
+
+    if (!r->headers_sent) {
+        ap_send_http_header_real(r);
+        ap_bflush(r->connection->client);
+        r->headers_sent = 1;
+    }
+
+    /* At this point we need to discover if there was any data saved from
+     * the last call to core_filter.
+     */
+    b = ap_get_saved_data(r, f, &b);
+
+    /* It is very obvious that we need to make sure it makes sense to send data
+     * out at this point.
+     */
+    dptr = b->head; 
+    while (dptr) { 
+        len += ap_get_bucket_len(dptr);
+        dptr = dptr->next;
+    }
+    if (len < MIN_SIZE_TO_WRITE && b->tail->color != AP_BUCKET_eos) {
+        ap_save_data_to_filter(r, f, b);
+        return 0;
+    } 
+    else {
+        ap_bucket_brigade_to_iol(&bytes_sent, b, r->connection->client->iol);
+        return bytes_sent;
+    }
+}
+
 static const handler_rec core_handlers[] = {
 { "*/*", default_handler },
 { "default-handler", default_handler },
@@ -2894,6 +2970,14 @@
 static unsigned short core_port(const request_rec *r)
     { return DEFAULT_HTTP_PORT; }
 
+static void core_register_filter(request_rec *r)
+{
+    if (r->chunked) {
+        ap_hook_filter(chunk_filter, r, NULL, NULL, AP_HOOK_TRANSPORT);
+    }
+    ap_hook_filter(core_filter, r, NULL, NULL, AP_HOOK_TRANSPORT_LAST);
+}
+
 static void register_hooks(void)
 {
     ap_hook_post_config(core_post_config,NULL,NULL,AP_HOOK_REALLY_FIRST);
@@ -2906,6 +2990,8 @@
     /* FIXME: I suspect we can eliminate the need for these - Ben */
     ap_hook_type_checker(do_nothing,NULL,NULL,AP_HOOK_REALLY_LAST);
     ap_hook_access_checker(do_nothing,NULL,NULL,AP_HOOK_REALLY_LAST);
+
+    ap_hook_insert_filter(core_register_filter, NULL, NULL, AP_HOOK_MIDDLE);
 }
 
 API_VAR_EXPORT module core_module = {
Index: main/http_protocol.c
===================================================================
RCS file: /home/cvs/apache-2.0/src/main/http_protocol.c,v
retrieving revision 1.96
diff -u -d -b -w -u -r1.96 http_protocol.c
--- main/http_protocol.c	2000/07/13 16:26:42	1.96
+++ main/http_protocol.c	2000/07/20 21:16:29
@@ -64,6 +64,8 @@
  */
 
 #define CORE_PRIVATE
+#include "apr_buf.h"
+#include "util_filter.h"
 #include "ap_config.h"
 #include "httpd.h"
 #include "http_config.h"
@@ -1812,7 +1814,11 @@
         ap_rfc822_date(date, r->request_time);
         ap_table_addn(r->headers_out, "Expires", date);
     }
+}
 
+API_EXPORT(void) ap_send_http_header_real(request_rec *r)
+{
+    const long int zero = 0L;
     /* Send the entire ap_table_t of header fields, terminated by an empty line. */
 
     ap_table_do((int (*) (void *, const char *, const char *)) ap_send_header_field,
@@ -2443,15 +2449,23 @@
                              size_t length)
 {
     size_t total_bytes_sent = 0;
-    int n;
-    ap_ssize_t w;
-    char *addr;
+    ap_bucket_brigade *bb = NULL;
+    ap_bucket *b = NULL;
+    ap_filter_t *f;
     
+    /* if you are using the older API's, then Apache will initiate the 
+     * filtering for you.
+     */
+    f = ap_init_filter(r->pool);   
+ 
     if (length == 0)
         return 0;
 
-
     length += offset;
+/* We can remove all of the MMAP_SEGMENT_SIZE stuff from Apache, because
+ * it is an optimization to be used for sending data.  Since we are using
+ * bucket-brigades we need to move this optimization down to the bucket
+ * brigade stuff, but that can wait for a day or two.
     while (!r->connection->aborted && offset < length) {
         if (length - offset > MMAP_SEGMENT_SIZE) {
             n = MMAP_SEGMENT_SIZE;
@@ -2467,76 +2481,132 @@
         total_bytes_sent += w;
         offset += w;
     }
+ */
 
-    SET_BYTES_SENT(r);
+    /* This is far too complex for a final API, but it is an okay
+     * start.  To finish this off, we will need a very clean API
+     * that does all of this for us.
+     */
+    bb = ap_bucket_brigade_create(r->pool);
+    b = ap_bucket_mmap_create();
+    b->insert(b, mm, mm->size, &total_bytes_sent);
+    bb->head = bb->tail = b;
+    total_bytes_sent = ap_pass_brigade(r, f, bb);
+
     return total_bytes_sent;
 }
 #endif /* USE_MMAP_FILES */
 
 API_EXPORT(int) ap_rputc(int c, request_rec *r)
 {
+    ap_bucket_brigade *bb = NULL;
+    ap_bucket *b = NULL;
+    ap_ssize_t written;
+    ap_filter_t *f;
+
     if (r->connection->aborted)
         return EOF;
 
-    if (ap_bputc(c, r->connection->client) < 0) {
-        check_first_conn_error(r, "rputc", 0);
-        return EOF;
-    }
-    SET_BYTES_SENT(r);
+    /* if you are using the older API's, then Apache will initiate the 
+     * filtering for you.
+     */
+    f = ap_init_filter(r->pool);   
+
+    /* This is far too complex for a final API, but it is an okay
+     * start.  To finish this off, we will need a very clean API
+     * that does all of this for us.
+     */
+    bb = ap_bucket_brigade_create(r->pool);
+    b = ap_bucket_rwmem_create();
+    b->insert(b, &c, 1, &written); 
+    bb->head = bb->tail = b;
+    ap_pass_brigade(r, f, bb);
+
     return c;
 }
 
 API_EXPORT(int) ap_rputs(const char *str, request_rec *r)
 {
-    int rcode;
+    ap_bucket_brigade *bb = NULL;
+    ap_bucket *b = NULL;
+    ap_ssize_t written;
+    ap_filter_t *f;
 
     if (r->connection->aborted)
         return EOF;
     
-    rcode = ap_bputs(str, r->connection->client);
-    if (rcode < 0) {
-        check_first_conn_error(r, "rputs", 0);
-        return EOF;
-    }
-    SET_BYTES_SENT(r);
-    return rcode;
+    /* if you are using the older API's, then Apache will initiate the 
+     * filtering for you.
+     */
+    f = ap_init_filter(r->pool);   
+
+    /* This is far too complex for a final API, but it is an okay
+     * start.  To finish this off, we will need a very clean API
+     * that does all of this for us.
+     */
+    bb = ap_bucket_brigade_create(r->pool);
+    b = ap_bucket_rwmem_create();
+    b->insert(b, str, strlen(str), &written); 
+    bb->head = bb->tail = b;
+    ap_pass_brigade(r, f, bb);
+
+    return written;
 }
 
 API_EXPORT(int) ap_rwrite(const void *buf, int nbyte, request_rec *r)
 {
-    ap_ssize_t n;
-    ap_status_t rv;
+    ap_bucket_brigade *bb = NULL;
+    ap_bucket *b = NULL;
+    ap_ssize_t written;
+    ap_filter_t *f;
 
     if (r->connection->aborted)
         return EOF;
 
-    /* ### should loop to avoid partial writes */
-    rv = ap_bwrite(r->connection->client, buf, nbyte, &n);
-    if (rv != APR_SUCCESS) {
-        check_first_conn_error(r, "rwrite", rv);
-        return EOF;
-    }
-    SET_BYTES_SENT(r);
-    return n;
+    /* if you are using the older API's, then Apache will initiate the 
+     * filtering for you.
+     */
+    f = ap_init_filter(r->pool);   
+
+    /* This is far too complex for a final API, but it is an okay
+     * start.  To finish this off, we will need a very clean API
+     * that does all of this for us.
+     */
+    bb = ap_bucket_brigade_create(r->pool);
+    b = ap_bucket_rwmem_create();
+    b->insert(b, buf, nbyte, &written); 
+    bb->head = bb->tail = b;
+    ap_pass_brigade(r, f, bb);
+    return written;
 }
 
 API_EXPORT(int) ap_vrprintf(request_rec *r, const char *fmt, va_list va)
 {
-    int n;
+    ap_bucket_brigade *bb = NULL;
+    ap_ssize_t written;
+    ap_filter_t *f;
 
     if (r->connection->aborted)
         return EOF;
 
-    n = ap_vbprintf(r->connection->client, fmt, va);
+    /* if you are using the older API's, then Apache will initiate the 
+     * filtering for you.
+     */
+    f = ap_init_filter(r->pool);   
 
-    if (n < 0) {
-        check_first_conn_error(r, "vrprintf", 0);
-        return EOF;
-    }
-    SET_BYTES_SENT(r);
-    return n;
+    /* This is far too complex for a final API, but it is an okay
+     * start.  To finish this off, we will need a very clean API
+     * that does all of this for us.
+     */
+    bb = ap_bucket_brigade_create(r->pool);
+    written = ap_brigade_vprintf(bb, fmt, va);
+    ap_pass_brigade(r, f, bb);
+    return written;
 }
 
+/* TODO:  Make ap pa_bucket_vprintf that printfs directly into a
+ * bucket.
+ */
 API_EXPORT_NONSTD(int) ap_rprintf(request_rec *r, const char *fmt, ...)
 {
     va_list va;
@@ -2546,46 +2616,58 @@
         return EOF;
 
     va_start(va, fmt);
-    n = ap_vbprintf(r->connection->client, fmt, va);
+    n = ap_vrprintf(r, fmt, va);
     va_end(va);
 
-    if (n < 0) {
-        check_first_conn_error(r, "rprintf", 0);
-        return EOF;
-    }
-    SET_BYTES_SENT(r);
     return n;
 }
 
 API_EXPORT_NONSTD(int) ap_rvputs(request_rec *r, ...)
 {
+    ap_bucket_brigade *bb = NULL;
+    ap_ssize_t written;
+    ap_filter_t *f;
     va_list va;
-    int n;
 
     if (r->connection->aborted)
         return EOF;
 
+    /* if you are using the older API's, then Apache will initiate the 
+     * filtering for you.
+     */
+    f = ap_init_filter(r->pool);   
+
+    /* This is far too complex for a final API, but it is an okay
+     * start.  To finish this off, we will need a very clean API
+     * that does all of this for us.
+     */
+    bb = ap_bucket_brigade_create(r->pool);
     va_start(va, r);
-    n = ap_vbputstrs(r->connection->client, va);
+    written = ap_brigade_vputstrs(bb, va);
     va_end(va);
-
-    if (n < 0) {
-        check_first_conn_error(r, "rvputs", 0);
-        return EOF;
-    }
-
-    SET_BYTES_SENT(r);
-    return n;
+    ap_pass_brigade(r, f, bb);
+    return written;
 }
 
 API_EXPORT(int) ap_rflush(request_rec *r)
 {
-    ap_status_t rv;
+    ap_bucket_brigade *bb;
+    ap_bucket *b;
+    ap_filter_t *f;
 
-    if ((rv = ap_bflush(r->connection->client)) != APR_SUCCESS) {
-        check_first_conn_error(r, "rflush", rv);
-        return EOF;
-    }
+    /* if you are using the older API's, then Apache will initiate the 
+     * filtering for you.
+     */
+    f = ap_init_filter(r->pool);   
+
+    /* This is far too complex for a final API, but it is an okay
+     * start.  To finish this off, we will need a very clean API
+     * that does all of this for us.
+     */
+    bb = ap_bucket_brigade_create(r->pool);
+    b = ap_bucket_eos_create();
+    bb->head = bb->tail = b;
+    ap_pass_brigade(r, f, bb);
     return 0;
 }
 
Index: main/http_request.c
===================================================================
RCS file: /home/cvs/apache-2.0/src/main/http_request.c,v
retrieving revision 1.35
diff -u -d -b -w -u -r1.35 http_request.c
--- main/http_request.c	2000/06/24 17:33:57	1.35
+++ main/http_request.c	2000/07/20 21:16:29
@@ -1263,6 +1263,12 @@
         return;
     }
 
+    /* We need to flush the data out at this point.  We probably only want to
+     * do this on the main request, but this is fine for an initial patch.
+     * Once we look into this more, we won't flush sub-requests.
+     */
+    ap_rflush(r);
+
     /* Take care of little things that need to happen when we're done */
     ap_finalize_request_protocol(r);
 }
